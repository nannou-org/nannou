diff a/nannou_wgpu/src/render_pipeline_builder.rs b/nannou_wgpu/src/render_pipeline_builder.rs	(rejected hunks)
@@ -4,8 +4,6 @@
 //! have to consider when writing graphics code. Here we define a set of helpers that allow us to
 //! simplify the process and fall back to a set of reasonable defaults.
 
-use wgpu_upstream::ColorTargetState;
-
 use crate as wgpu;
 
 #[derive(Debug)]
@@ -54,7 +52,7 @@ impl<'a> RenderPipelineBuilder<'a> {
         front_face: Self::DEFAULT_FRONT_FACE,
         cull_mode: Self::DEFAULT_CULL_MODE,
         polygon_mode: Self::DEFAULT_POLYGON_MODE,
-        unclipped_depth: Self::DEFAULT_UNCLIPPED_DEPTH,
+        clamp_depth: Self::DEFAULT_CLAMP_DEPTH,
         conservative: false,
     };
 
@@ -103,7 +101,7 @@ impl<'a> RenderPipelineBuilder<'a> {
         slope_scale: Self::DEFAULT_DEPTH_BIAS_SLOPE_SCALE,
         clamp: Self::DEFAULT_DEPTH_BIAS_CLAMP,
     };
-    pub const DEFAULT_UNCLIPPED_DEPTH: bool = false;
+    pub const DEFAULT_CLAMP_DEPTH: bool = false;
     pub const DEFAULT_DEPTH_STENCIL: wgpu::DepthStencilState = wgpu::DepthStencilState {
         format: Self::DEFAULT_DEPTH_FORMAT,
         depth_write_enabled: Self::DEFAULT_DEPTH_WRITE_ENABLED,
@@ -391,7 +389,7 @@ impl<'a> RenderPipelineBuilder<'a> {
     ///
     /// Requires `Features::DEPTH_CLAMPING` enabled.
     pub fn clamp_depth(mut self, b: bool) -> Self {
-        self.primitive.unclipped_depth = b;
+        self.primitive.clamp_depth = b;
         self
     }
 
@@ -478,18 +476,12 @@ impl<'a> RenderPipelineBuilder<'a> {
     /// - A rasterization state field was specified but no fragment shader was given.
     /// - A color state field was specified but no fragment shader was given.
     pub fn build(self, device: &wgpu::Device) -> wgpu::RenderPipeline {
-        let color_states = self
-            .color_states
-            .to_vec()
-            .into_iter()
-            .map(Some)
-            .collect::<Vec<_>>();
         match self.layout {
             Layout::Descriptor(ref desc) => {
                 let layout = device.create_pipeline_layout(desc);
-                build(self, &layout, device, &color_states[..])
+                build(self, &layout, device)
             }
-            Layout::Created(layout) => build(self, layout, device, &color_states[..]),
+            Layout::Created(layout) => build(self, layout, device),
         }
     }
 }
@@ -514,7 +506,6 @@ fn build(
     builder: RenderPipelineBuilder,
     layout: &wgpu::PipelineLayout,
     device: &wgpu::Device,
-    color_states: &[Option<ColorTargetState>],
 ) -> wgpu::RenderPipeline {
     let RenderPipelineBuilder {
         layout: _layout,
@@ -524,10 +515,10 @@ fn build(
         fs_entry_point,
         primitive,
         color_state,
+        color_states,
         depth_stencil,
         multisample,
         vertex_buffers,
-        ..
     } = builder;
 
     let vertex = wgpu::VertexState {
@@ -536,23 +527,21 @@ fn build(
         buffers: &vertex_buffers[..],
     };
 
-    let mut single_color_state = [Some(RenderPipelineBuilder::DEFAULT_COLOR_STATE)];
-
+    let mut single_color_state = [RenderPipelineBuilder::DEFAULT_COLOR_STATE];
     let color_states = match (fs_mod.is_some(), color_states.is_empty()) {
         (true, true) => {
             if let Some(cs) = color_state {
-                single_color_state[0] = Some(cs);
+                single_color_state[0] = cs;
             }
             &single_color_state[..]
         }
         (true, false) => color_states,
         (false, true) => panic!("specified color states but no fragment shader"),
-        (false, false) => &match color_state.is_some() {
+        (false, false) => match color_state.is_some() {
             true => panic!("specified color state fields but no fragment shader"),
-            false => [None],
+            false => &[],
         },
     };
-
     let fragment = match (fs_mod, color_states.is_empty()) {
         (Some(fs_mod), false) => Some(wgpu::FragmentState {
             module: &fs_mod,
@@ -570,7 +559,6 @@ fn build(
         depth_stencil,
         multisample,
         fragment,
-        multiview: None,
     };
 
     device.create_render_pipeline(&pipeline_desc)
