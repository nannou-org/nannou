<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OSC - Sending OSC - The Nannou Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A one-stop shop for Nannou Knowledge!">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Nannou Guide</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sending-osc"><a class="header" href="#sending-osc">Sending OSC</a></h1>
<p><strong>Tutorial Info</strong></p>
<ul>
<li>Author: <a href="https://madskjeldgaard.dk">madskjeldgaard</a></li>
<li>Required Knowledge:
<ul>
<li><a href="/tutorials/basics/anatomy-of-a-nannou-app.html">Anatomy of a nannou App</a></li>
<li><a href="/tutorials/basics/drawing-2d-shapes.html">Drawing 2D Shapes</a></li>
<li><a href="/tutorials/tutorial/moving-a-circle-about.html">Moving a circle about on the screen</a></li>
<li><a href="/tutorials/osc/osc-introduction.html">OSC introduction</a></li>
</ul>
</li>
<li>Reading Time: 20 minutes</li>
</ul>
<hr />
<p>In this tutorial we will cover how to send OSC data from a nannou app to another application using the <code>nannou_osc</code> crate.</p>
<p>We are going to write a simple program which has a circle moving about on the screen while the circle's position is sent via OSC to another application. We will continue working on the app from <a href="/tutorials/basics/moving-a-circle-about.html">Moving a circle about on the screen</a>.</p>
<h2 id="setting-up-an-osc-sender"><a class="header" href="#setting-up-an-osc-sender">Setting up an OSC sender</a></h2>
<p>At the top of your <code>main.rs</code>-file, import the <code>nannou_osc</code> crate and make it available in your program via the shorthand <code>osc</code>.</p>
<pre><pre class="playground"><code class="language-rust  norun"><span class="boring">#![allow(unused_imports)]
</span>use nannou_osc as osc;
<span class="boring">fn main(){}</span></code></pre></pre>
<p>The first thing we then need to do is set up our OSC-sender in the <code>Model</code>-struct you may have seen in other nannou-tutorials.
Add a field to the struct called <code>sender</code> with a <a href="https://docs.rs/nannou_osc/latest/nannou_osc/send/struct.Sender.html">Sender</a>-struct as the type input.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code, unused_imports)]
</span><span class="boring">use nannou_osc as osc;
</span>struct Model {
    sender: osc::Sender&lt;osc::Connected&gt;,
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Next, we need to setup our <code>Model</code> struct using the <code>model</code> function. Don't worry if it looks a bit daunting at first, we will go through it step by step.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code, unused_imports)]
</span><span class="boring">use nannou_osc as osc;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {
</span><span class="boring">  sender: osc::Sender&lt;osc::Connected&gt;,
</span><span class="boring">}
</span>fn model(_app: &amp;App) -&gt; Model {
    let port = 1234;
    let target_addr = format!("{}:{}", "127.0.0.1", port);

	let sender = osc::sender()
        .expect("Could not bind to default socket")
        .connect(target_addr)
        .expect("Could not connect to socket at address");

    Model { sender }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>First, let's choose the network port that our data will be sent to.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let port = 1234;
<span class="boring">}</span></code></pre></pre>
<p>The osc-sender expects a string in the format "address:port", for example <code>"127.0.0.1:1234"</code>.</p>
<p>The address can either be an internal address or the address of another computer on your network. In this tutorial we will be targetting our own computer's internal address which is represented by <code>"127.0.0.1"</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let port = 1234;
</span>let target_addr = format!("{}:{}", "127.0.0.1", port);
<span class="boring">}</span></code></pre></pre>
<p>Lastly, we need to bind our OSC sender to the network socket. This isn't always successful, so we are attaching the <code>expect()</code>-method (read more about <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>expect()</code> here</a>) to post an error message if it is not successful. If it is successful, the <code>.connect(target_addr)</code>-method is used to connect the sender to the target address. Again, this may be unsuccesful so we use the <code>expect()</code>-method on the result of that operation as well.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">use nannou_osc as osc;
</span><span class="boring">fn main() {
</span><span class="boring">    let port = 1234;
</span><span class="boring">    let target_addr = format!("{}:{}", "127.0.0.1", port);
</span>let sender = osc::sender()
    .expect("Could not bind to default socket")
    .connect(target_addr)
    .expect("Could not connect to socket at address");
<span class="boring">}</span></code></pre></pre>
<h3 id="sending-osc-messages"><a class="header" href="#sending-osc-messages">Sending OSC messages</a></h3>
<p>An OSC packet consists of at least two components: An OSC address and 0 or more arguments containing data. The OSC address is not to be confused with the network address we connected to before. Instead, an OSC address is a path sort of like a URL, for example <code>/circle/position</code>.</p>
<p>To create an OSC packet, we first need to make an address.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let osc_addr = "/circle/position".to_string();
<span class="boring">}</span></code></pre></pre>
<p>Then create a vector of arguments. These need to be formatted using the types found in <a href="https://docs.rs/nannou_osc/latest/nannou_osc/enum.Type.html">osc::Type</a> in the nannou_osc crate. Below we create an argument list of two floating point values: the <code>x</code> and <code>y</code> coordinates of our circle.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">use nannou_osc as osc;
</span><span class="boring">fn main() {
</span><span class="boring">let x = 0.0;
</span><span class="boring">let y = 0.0;
</span>let args = vec![osc::Type::Float(x), osc::Type::Float(y)];
<span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<p>Now, bringing these two things together we get an OSC packet. The sender expect these to be delivered in a tuple.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let osc_addr = unimplemented!();
</span><span class="boring">let args = unimplemented!();
</span>let packet = (osc_addr, args);
<span class="boring">}</span></code></pre></pre>
<p><a href="https://docs.rs/nannou_osc/latest/nannou_osc/send/struct.Sender.html#method.send-1">Reading the documentation</a> for the <code>send</code>-method, we can see that it returns a Result type which will either contain the number of bytes written (if it was successful) and, more importantly, some useful errors of type CommunicationError if it was not succesful. To discard the error part of this, we use the <code>ok()</code> method at the end.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou_osc as osc;
</span><span class="boring">struct Model {
</span><span class="boring">   sender: osc::Sender&lt;osc::Connected&gt;,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">   let model: Model = unimplemented!();
</span><span class="boring">   let osc_addr = "/circle/position".to_string();
</span><span class="boring">   let args = vec![osc::Type::Float(0.0), osc::Type::Float(0.0)];
</span><span class="boring">   let packet = (osc_addr, args);
</span>    model.sender.send(packet).ok();
<span class="boring">}</span></code></pre></pre>
<h2 id="the-finished-app"><a class="header" href="#the-finished-app">The finished app</a></h2>
<pre><pre class="playground"><code class="language-rust no_run">use nannou::prelude::*;
use nannou_osc as osc;

fn main() {
    nannou::app(model).simple_window(view).run();
}

struct Model {
    sender: osc::Sender&lt;osc::Connected&gt;,
}

fn model(_app: &amp;App) -&gt; Model {
    // The network port that data is being sent to
    let port = 1234;

    // The osc-sender expects a string in the format "address:port", for example "127.0.0.1:1234"
    // "127.0.0.1" is equivalent to your computers internal address.
    let target_addr = format!("{}:{}", "127.0.0.1", port);

    // This is the osc Sender which contains a couple of expectations in case something goes wrong.
    let sender = osc::sender()
        .expect("Could not bind to default socket")
        .connect(target_addr)
        .expect("Could not connect to socket at address");

    Model { sender }
}

fn view(app: &amp;App, model: &amp;Model, frame: Frame) {
    // Use app time to progress through a sine wave
    let sine = app.time.sin();
    let slowersine = (app.time / 2.0).sin();

    // Get boundary of the window (to constrain the movements of our circle)
    let boundary = app.window_rect();

    // Map the sine wave functions to ranges between the boundaries of the window
    let x = map_range(sine, -1.0, 1.0, boundary.left(), boundary.right());
    let y = map_range(slowersine, -1.0, 1.0, boundary.bottom(), boundary.top());

    // Send x-y coordinates as OSC
    let osc_addr = "/circle/position".to_string();
    let args = vec![osc::Type::Float(x), osc::Type::Float(y)];
    let packet = (osc_addr, args);

    model.sender.send(packet).ok();

    // Prepare to draw.
    let draw = app.draw();

    // Clear the background to purple.
    draw.background().color(PLUM);

    // Draw a blue ellipse at the x/y coordinates 0.0, 0.0
    draw.ellipse().color(STEELBLUE).x_y(x, y);

    draw.to_frame(app, &amp;frame).unwrap();
}</code></pre></pre>
<p>In the next tutorial we will take a look at how to receive our OSC values and do something interesting with them.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../tutorials/osc/osc-introduction.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../community_tutorials.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../tutorials/osc/osc-introduction.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../community_tutorials.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
