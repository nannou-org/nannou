<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Nannou Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A one-stop shop for Nannou Knowledge!">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Nannou Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome!</a></h1>
<p><strong>Nannou is an open-source, creative-coding toolkit for Rust.</strong></p>
<p>The aim of this guide is to help you find the information you are looking for.
Whether you are new to Nannou and are looking for a place to start, or you are
an experienced Nannou user looking for more advanced tutorials, this book should
have something for you!</p>
<p>As excited as we are about developing tools for creative coding, we are equally
excited about fostering a warm, welcoming and inclusive community. Please make
yourself familiar with our <a href="/code_of_conduct.html">Code of Conduct</a> and feel free
to join us on the Nannou
<a href="https://communityinviter.com/apps/nannou/nannou-slack">Slack</a> or
<a href="https://matrix.to/#/+nannou:matrix.org">Matrix</a> community.</p>
<h3 id="why-nannou"><a class="header" href="#why-nannou"><a href="/why_nannou.html">Why Nannou?</a></a></h3>
<p>Here you can read about the motivations and philosophy behind Nannou. Why start
Nannou? What drives forward progress?</p>
<h3 id="getting-started"><a class="header" href="#getting-started"><a href="/getting_started.html">Getting Started</a></a></h3>
<p>Is this your first time using Nannou or Rust? This is the chapter for you.
This chapter covers everything from installing Rust right through to starting
your own Nannou project.</p>
<h3 id="tutorials"><a class="header" href="#tutorials"><a href="/tutorials.html">Tutorials</a></a></h3>
<p>A suite of tutorials demonstrating how to do different things with Nannou. For
example, "How do I output sounds?", "How do I draw shapes?", "How can I connect
to my laser?"</p>
<blockquote>
<p>You can find more tutorials by the community <a href="/community_tutorials.html">here</a>.</p>
</blockquote>
<h3 id="developer-reference"><a class="header" href="#developer-reference"><a href="/developer_reference.html">Developer Reference</a></a></h3>
<p>Learn more about the design philosophy behind Nannou, how the project is
architected and how you can contribute.</p>
<h3 id="api-reference"><a class="header" href="#api-reference"><a href="https://docs.rs/nannou">API Reference</a></a></h3>
<p>If you are looking for the source code reference, check out
<a href="https://docs.rs/nannou">docs.rs/nannou</a>. Here you can find documentation about
the API generated from the code itself.</p>
<h3 id="showcases"><a class="header" href="#showcases"><a href="/showcases.html">Showcases</a></a></h3>
<p>See what's possible with Nannou! A collection of projects made with Nannou.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-nannou-1"><a class="header" href="#why-nannou-1">Why Nannou?</a></h1>
<p><strong>nannou</strong> is a collection of code aimed at making it easy for artists to
express themselves with simple, fast, reliable, portable code.  Whether working
on a 12-month installation or a 5 minute sketch, this framework aims to give
artists easy access to the tools they need.</p>
<p>The project was started out of a desire for a creative coding framework inspired
by Processing, OpenFrameworks and Cinder, but for Rust. <sup>Named after
<a href="https://www.youtube.com/watch?v=A-Pkx37kYf4">this</a>.</sup></p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>Nannou aims to provide easy, cross-platform access to the things that artists
need:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Windowing &amp; Events</strong> via <a href="https://crates.io/crates/winit">winit</a>.</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Audio</strong> via <a href="https://crates.io/crates/cpal">CPAL</a>. <em>Input and
output streams. Duplex are not yet supported.</em></li>
<li><input disabled="" type="checkbox"/>
<strong>Video</strong> input, playback and processing (<em>would love suggestions and
ideas</em>).</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>GUI</strong> via <a href="https://crates.io/crates/egui">egui</a>. <em>May switch to a custom
nannou solution <a href="https://github.com/nannou-org/nannou/issues/383">in the
future</a></em>.</li>
<li><strong>Geometry</strong> with functions and iterators for producing vertices and indices:
<ul>
<li><input disabled="" type="checkbox" checked=""/>
1D - <code>Scalar</code>, <code>Range</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
2D - <code>Path</code>, <code>Polyline</code>, <code>Polygon</code>, <code>Rect</code>, <code>Line</code>, <code>Ellipse</code>, <code>Quad</code>,
<code>Tri</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
3D - <code>Cuboid</code>.</li>
<li><input disabled="" type="checkbox"/>
3D TODO - <code>Ellipsoid</code>, <code>Cube</code>, Prisms, Pyramids, *Hedrons, Camera, etc.</li>
<li><input disabled="" type="checkbox" checked=""/>
Vertex &amp; index iterators.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou/latest/nannou/geom/graph/index.html">Graph</a> for
composing geometry.</li>
</ul>
</li>
<li><strong>Graphics</strong> via WGPU (via <a href="https://github.com/gfx-rs/wgpu-rs">wgpu-rs</a>):
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou/latest/nannou/draw/index.html">Draw</a> API. E.g.
<code>draw.ellipse().w_h(20.0, 20.0).color(RED)</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou/latest/nannou/mesh/index.html">Mesh</a> API.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou/latest/nannou/image/index.html">Image</a> API.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou/latest/nannou/wgpu/struct.Texture.html">Texture</a> API.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou/latest/nannou/wgpu/index.html">WGPU</a> API.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou/latest/nannou/text/index.html">Text</a> API.</li>
<li><input disabled="" type="checkbox"/>
Shader hot-loading. <em>See
<a href="https://github.com/nannou-org/hotglsl">hotglsl</a> and <a href="https://github.com/nannou-org/nannou/tree/master/nannou_isf">nannou_isf
WIP</a></em>.</li>
</ul>
</li>
<li><strong>Protocols</strong>:
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou_osc">OSC</a> - Open Sound
Control.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://github.com/nannou-org/isf">ISF</a> - Interactive Shader Format.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://github.com/nannou-org/citp">CITP</a> - Controller Interface
Transport Protocol (network implementation is in progress).</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://github.com/nannou-org/ether-dream">Ether-Dream</a> Laser DAC
protocol and network implementation.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://github.com/lschmierer/sacn">DMX via sACN</a> - commonly used for
lighting and effects.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://crates.io/crates/serial">Serial</a> - commonly used for
interfacing with LEDs and other hardware.</li>
<li><input disabled="" type="checkbox"/>
MIDI - No friendly nannou API is provided yet, but cross-platform MIDI I/O is possible via <a href="https://crates.io/crates/midir">midir</a>.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://doc.rust-lang.org/std/net/struct.UdpSocket.html">UDP</a> via
std.</li>
<li><input disabled="" type="checkbox" checked=""/>
TCP
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">streams</a> and
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">listeners</a>
via std.</li>
</ul>
</li>
<li><strong>Device &amp; I/O stream APIs</strong>:
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Windowing.</li>
<li><input disabled="" type="checkbox" checked=""/>
Application events.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://docs.rs/nannou/latest/nannou/app/struct.Audio.html">Audio</a>.</li>
<li><input disabled="" type="checkbox"/>
Video.</li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://github.com/nannou-org/nannou/tree/master/nannou_laser">Lasers</a>.</li>
<li><input disabled="" type="checkbox"/>
Lights. <em>For now, we recommend DMX via the <a href="https://docs.rs/sacn/0.4.4/sacn/">sacn crate</a>.</em></li>
<li><input disabled="" type="checkbox"/>
LEDs. <em>For now, we recommend DMX via the <a href="https://docs.rs/sacn/0.4.4/sacn/">sacn crate</a>.</em></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<strong>Graphical Node Graph</strong> via <a href="https://github.com/nannou-org/gantz">gantz</a>.</li>
<li><input disabled="" type="checkbox"/>
<strong>GUI Editor</strong>.</li>
</ul>
<p>Nannou aims to <strong>use only pure-rust libraries</strong>. As a new user you should
require nothing more than <code>cargo build</code> to get going. Falling back to C-bindings
will be considered as a temporary solution in the case that there are no Rust
alternatives yet in development. We prefer to drive forward development of less
mature rust-alternatives than depend on bindings to C code. This should make it
easier for nannou <em>users</em> to become nannou <em>contributors</em> as they do not have to
learn a second language in order to contribute upstream.</p>
<p>Nannou <strong>will not contain <code>unsafe</code> code</strong> with the exception of bindings to
operating systems or hardware APIs if necessary.</p>
<p>Nannou wishes to <strong>remove the need to decide between lots of different backends
that provide access to the same hardware</strong>. Instead, we want to focus on a
specific set of backends and make sure that they work well.</p>
<h2 id="why-rust"><a class="header" href="#why-rust">Why Rust?</a></h2>
<p>Rust is a language that is both highly expressive and blazingly fast. Here are
some of the reasons why we choose to use it:</p>
<ul>
<li><strong>Super fast</strong>, as in <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-gpp.html">C and
C++ fast</a>.</li>
<li><a href="https://crates.io/"><strong>A standard package manager</strong></a> that makes it very
easy to handle dependencies and share your own projects in seconds.</li>
<li><strong>Highly portable.</strong> Easily build for MacOS, Linux, Windows, Android, iOS and
<a href="https://forge.rust-lang.org/platform-support.html">so many others</a>.</li>
<li><strong>No header files</strong> and no weird linking errors.</li>
<li><strong>Sum Types and Pattern Matching</strong> and no <code>NULL</code>.</li>
<li><strong>Local type inference</strong>. Only write types where it matters, no need to repeat
yourself.</li>
<li>A more modern, <strong>ƒunctional and expressive style</strong>.</li>
<li><strong>Memory safe and data-race-free!</strong> Get your ideas down without the fear of
creating pointer spaghetti or segfault time-sinks.</li>
<li><strong>Immutability by default.</strong> Easily distinguish between variables that can
change and those that can't at a glance.</li>
<li><strong>Module system</strong> resulting in very clean and concise name spaces.</li>
<li>One of the kindest internet communities we've come across. Please visit
mozilla's #rust or /r/rust if you're starting out and need any pointers.</li>
</ul>
<h2 id="why-the-apachemit-dual-licensing"><a class="header" href="#why-the-apachemit-dual-licensing">Why the Apache/MIT dual licensing?</a></h2>
<p>For the most part, nannou is trying to maintain as much flexibility and compatibility
with the licensing of Rust itself, which is also <a href="https://www.rust-lang.org/policies/licenses">dual licensed</a>.</p>
<p>The Apache 2.0 and MIT license are very similar, but have a few key differences.
Using the Apache 2.0 license for contributions triggers the Apache 2.0 patent grant.
This grant is designed to protect against leveraging the patent law system to bypass
(some) terms of the license. If the contribution is under the Apache 2.0 license, the
contributor assures that they will not claim a violation of (their own) patents. If
someone makes a work based on Apache 2.0 licensed code, they in turn also vow to
not sue their users (for patent infringement).
The MIT license provides compatibility with a lot of other FLOSS licenses.</p>
<p>Further reading:</p>
<ul>
<li><a href="https://opensource.org/licenses/Apache-2.0">Apache License, Version 2.0</a></li>
<li><a href="https://opensource.org/licenses/MIT">MIT License</a></li>
<li><a href="https://mail.mozilla.org/pipermail/rust-dev/2012-November/002664.html">Please read: Rust license changing (very slightly)</a></li>
<li><a href="https://internals.rust-lang.org/t/rationale-of-apache-dual-licensing/8952">Rationale of Apache dual licensing</a></li>
<li><a href="https://opensource.stackexchange.com/questions/1881/against-what-does-the-apache-2-0-patent-clause-protect">Against what does the Apache 2.0 patent clause protect?</a></li>
<li><a href="https://blog.gerv.net/2016/09/gplv2-combination-exception-for-the-apache-2-license/">GPLv2 Combination Exception for the Apache 2 License</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h1>
<p>If you are new to nannou or Rust, you are in the right place!</p>
<p>In this section, we will:</p>
<ol>
<li>Install the Rust programming language.</li>
<li>Check for platform-specific requirements.</li>
<li>Setup our code editor for working with Rust.</li>
<li>Run some nannou examples.</li>
<li>Make our own, new nannou project!</li>
</ol>
<p>Let's get started.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-specific-setup"><a class="header" href="#platform-specific-setup">Platform-specific Setup</a></h1>
<p>Before we get started, let's make sure we have all the necessary ingredients for
installing Rust and building nannou projects.</p>
<p>Depending on what OS you are running, you might require an extra step or two.</p>
<p>By the way, if you notice some steps are missing from this section of the guide,
feel free to open an issue or PR at <a href="https://github.com/nannou-org/nannou/tree/master/guide">the nannou guide
repo</a>!</p>
<h2 id="macos"><a class="header" href="#macos">macOS</a></h2>
<p>Ensure that you have xcode-tools installed:</p>
<pre><code class="language-bash">xcode-select --install
</code></pre>
<p>Some examples require that you have <code>cmake</code> installed as well. The easiest way to achieve this is to use <a href="https://brew.sh">Homebrew</a>.</p>
<pre><code class="language-bash">brew install cmake
</code></pre>
<p>This should provide all the developer tools needed for building nannou.</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>Rust requires the C++ build tools for Visual Studio. The Rust book has this to
say:</p>
<blockquote>
<p>On Windows, go to
<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a>
and follow the instructions for installing Rust. At some point in the
installation, you’ll receive a message explaining that you’ll also need the
C++ build tools for Visual Studio 2013 or later. The easiest way to acquire
the build tools is to install <a href="https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019">Build Tools for Visual Studio
2019</a>.
The tools are in the Other Tools and Frameworks section.</p>
</blockquote>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<p>Ensure you have the following system packages installed:</p>
<ul>
<li>
<p><strong>Basic dev packages</strong></p>
<p>First make sure the basic dev packages are installed.</p>
<ul>
<li><code>curl</code> will be required by <code>rustup</code> the rust toolchain manager.</li>
<li><code>build-essential</code> will be required by <code>rustc</code> the rust compiler for linking.</li>
<li><code>pkg-config</code> is used by some build scripts to source information about
certain libraries.</li>
<li><code>alsa</code> dev packages are required for <code>nannou_audio</code>.</li>
</ul>
<p>For Debian/Ubuntu users:</p>
<pre><code class="language-bash">sudo apt-get install curl build-essential python cmake pkg-config
</code></pre>
</li>
<li>
<p><strong>alsa dev package</strong></p>
<p>For Fedora users:</p>
<pre><code class="language-bash">sudo dnf install alsa-lib-devel
</code></pre>
<p>For Debian/Ubuntu users:</p>
<pre><code class="language-bash">sudo apt-get install libasound2-dev
</code></pre>
<p>For Arch users:</p>
<pre><code class="language-bash">sudo pacman -S alsa-lib
</code></pre>
</li>
<li>
<p><strong>curl lib dev package</strong></p>
<p>Nannou depends on the <code>curl-sys</code> crate. Some Linux distributions use
LibreSSL instead of OpenSSL (such as AlpineLinux, Voidlinux, possibly
<a href="https://en.wikipedia.org/wiki/LibreSSL#Adoption">others</a> if manually
installed).</p>
</li>
<li>
<p><strong>xcb</strong></p>
<p>The XCB library provides inter-operability with Xlib.</p>
<p>For Debian/Ubuntu users:</p>
<pre><code class="language-bash">sudo apt install libxcb-shape0-dev libxcb-xfixes0-dev
</code></pre>
<p>You might also need <code>python3</code> for the <code>xcb</code> crate's build script.</p>
</li>
<li>
<p><strong>vulkan</strong></p>
<p>Installing Vulkan support on Linux is generally quite easy using your
distro's package manager. That said, there may be different driver
options to consider depending on your graphics card and tolerance for
proprietary software. The following are rough guidelines on how to get
going quickly, however if you are at all concerned with finding the
approach that suits you best we recommend searching for vulkan driver
installation for your graphics card on your distro.</p>
<p>For Fedora with AMD graphic cards:</p>
<pre><code class="language-bash">sudo dnf install vulkan vulkan-info
</code></pre>
<p>For Fedora with NVIDIA graphic cards:
Add the proprietary drivers</p>
<pre><code class="language-bash">sudo dnf install https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm
</code></pre>
<p>and run</p>
<pre><code class="language-bash">sudo dnf install xorg-x11-drv-nvidia akmod-nvidia vulkan-tools
</code></pre>
<p>For Debian with AMD or Intel graphic cards:</p>
<pre><code class="language-bash">sudo apt-get install libvulkan1 mesa-vulkan-drivers vulkan-utils
</code></pre>
<p>For Debian with NVIDIA graphic cards:</p>
<pre><code class="language-bash">sudo apt-get install vulkan-tools
</code></pre>
<p>Or, on older versions (pre-Buster i.e., &lt; 10):</p>
<pre><code class="language-bash">sudo apt-get install vulkan-utils
</code></pre>
<p>For Ubuntu users with AMD or Intel graphic cards:
Add a PPA for the latest drivers</p>
<pre><code class="language-bash">sudo add-apt-repository ppa:oibaf/graphics-drivers
sudo apt-get update
sudo apt-get upgrade
</code></pre>
<p>and run</p>
<pre><code class="language-bash">sudo apt-get install libvulkan1 mesa-vulkan-drivers vulkan-utils
</code></pre>
<p>For Ubuntu users with NVIDIA graphic cards:
Add a PPA for the latest drivers</p>
<pre><code class="language-bash">sudo add-apt-repository ppa:graphics-drivers/ppa
sudo apt-get update
sudo apt-get upgrade
</code></pre>
<p>and run</p>
<pre><code class="language-bash">sudo apt-get install nvidia-graphics-drivers-396 nvidia-settings vulkan vulkan-utils
</code></pre>
<p>For Arch with AMD graphic cards:</p>
<pre><code class="language-bash">sudo pacman -S vulkan-radeon lib32-vulkan-radeon
</code></pre>
<p>For Arch with Intel graphics card:</p>
<pre><code class="language-bash">sudo pacman -S vulkan-intel
</code></pre>
<p>For Arch with NVIDIA graphic cards:</p>
<pre><code class="language-bash">sudo pacman -S nvidia lib32-nvidia-utils
</code></pre>
<p>For Gentoo run:</p>
<pre><code class="language-bash">sudo emerge --ask --verbose dev-util/vulkan-tools dev-util/vulkan-headers
</code></pre>
</li>
</ul>
<p>OK, we should now be ready to install Rust!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h1>
<p>Nannou is a library written for the <a href="https://www.rust-lang.org/">Rust programming
language</a>. Thus, the first step is to install Rust!</p>
<p>To install Rust on <strong>Windows</strong>, download and run the installer from
<a href="https://www.rust-lang.org/tools/install">here</a>. If you're on <strong>macOS</strong> or
<strong>Linux</strong>, open up your terminal, copy the text below, paste it into your
terminal and hit enter.</p>
<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Now Rust is installed!</p>
<p>Next we will install some tools that help IDEs do fancy things like
auto-completion and go-to-definition.</p>
<pre><code class="language-bash">rustup component add rust-src rustfmt-preview rust-analysis
</code></pre>
<p>Please see <a href="https://www.rust-lang.org/tools/install">this link</a> if you would
like more information on the Rust installation process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editor-setup"><a class="header" href="#editor-setup">Editor Setup</a></h1>
<p>While most popular development environments support Rust, support for certain
features like auto-completion and go-to-definition is better in some than
others.</p>
<h3 id="vs-code"><a class="header" href="#vs-code">VS Code</a></h3>
<p>For new Rust users we recommend using VS-Code as your editor and IDE for Nannou
development. Currently it seems to have the best support for the Rust language
including syntax highlighting, auto-complete, code formatting and more. It also
comes with an integrated unix terminal and file navigation system. Below are the
steps we recommend for getting started with Nannou development using VS-Code.</p>
<ol>
<li><a href="https://code.visualstudio.com/download">Download VS-Code</a> for your OS.</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer">Install
rust-analyzer</a> plugin for VS-Code.</li>
<li>Click on the 'view' menu and select 'terminal'.</li>
</ol>
<h3 id="other-environments"><a class="header" href="#other-environments">Other Environments</a></h3>
<p>Here are links to assist with setting up other popular development environments
for supporting Rust.</p>
<ol>
<li><a href="https://packagecontrol.io/packages/Rust%20Enhanced">Sublime Text</a></li>
<li><a href="https://atom.io/packages/language-rust">Atom</a></li>
<li><a href="https://intellij-rust.github.io">Intellij IDEA</a></li>
<li><a href="https://github.com/rust-lang/rust.vim">Vim</a></li>
<li><a href="https://github.com/rust-lang/rust-mode">Emacs</a></li>
<li><a href="https://github.com/PistonDevelopers/VisualRust">Visual Studio</a></li>
<li><a href="https://github.com/eclipse/corrosion">Eclipse</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-examples"><a class="header" href="#running-examples">Running Examples</a></h1>
<p>The easiest way to get familiar with nannou is to explore the examples.</p>
<p>Nannou provides three collections of examples:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Path</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td><a href="https://github.com/nannou-org/nannou/tree/master/examples"><strong><code>examples/</code></strong></a></td><td>A collection of examples with categorised demonstrations of nannou.</td></tr>
<tr><td><a href="https://github.com/nannou-org/nannou/tree/master/generative_design"><strong><code>generative_design/</code></strong></a></td><td>Examples from <a href="http://www.generative-gestaltung.de/">Generative Gestaltung</a>, ported from p5.js to nannou.</td></tr>
<tr><td><a href="https://github.com/nannou-org/nannou/tree/master/nature_of_code"><strong><code>nature_of_code/</code></strong></a></td><td>Examples from <a href="https://natureofcode.com/">Nature of Code</a>, ported from Processing to nannou.</td></tr>
</tbody></table>
</div>
<p>To get the examples we can clone the nannou repository.</p>
<pre><code class="language-bash">git clone https://github.com/nannou-org/nannou
</code></pre>
<p>If you do not have <code>git</code> installed you can press the "Clone or download" button
at the top of this page and then press "Download .zip".</p>
<p>Now, change the current directory to <code>nannou</code>.</p>
<pre><code class="language-bash">cd nannou
</code></pre>
<p>Run the example using cargo!</p>
<pre><code class="language-bash">cargo run --release --example draw
</code></pre>
<p>The <code>--release</code> flag means we want to build with optimisations enabled.</p>
<p>The value passed via the <code>--example</code> flag matches the <code>name</code> property of an
entry within the <code>[[examples]]</code> table of the package's <code>Cargo.toml</code> file. The
matched entry's <code>path</code> property points to the source file to build:</p>
<pre><code class="language-toml"># Draw
[[example]]
name = "draw"
path = "draw/draw.rs"
</code></pre>
<p>If we were to look through the nature of code directory and decide we want to
run the following example:</p>
<pre><code class="language-toml"># Chapter 1 Vectors
[[example]]
name = "1_1_bouncingball_novectors"
path = "chp_01_vectors/1_1_bouncingball_novectors.rs"
</code></pre>
<p>We could do so with the following:</p>
<pre><code class="language-bash">cargo run --release --example 1_1_bouncingball_novectors
</code></pre>
<p>In general, the name of the example will almost always be the file name without
the <code>.rs</code> extension.</p>
<p>If you are compiling nannou for the first time you will see cargo download and
build all the necessary dependencies. This might take a while! Luckily, we only
have to wait for this the first time.</p>
<p><img src="https://i.imgur.com/5OBNqMB.gif" alt="cargo" /></p>
<p>Once the example compiles you should see the following window appear.</p>
<p><img src="https://i.imgur.com/HVVamUI.gif" alt="draw_HD" /></p>
<p>To run any of the other examples, replace <code>draw</code> with the name of the
desired example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-project"><a class="header" href="#create-a-project">Create A Project</a></h1>
<p>Whether we are creating an artwork, an app, a quick sketch or an installation,
we want to begin by creating a new project. A new nannou project lets us build a
nannou application the way that <em>we</em> want to use it.</p>
<p>Eventually, the aim for Nannou is to provide a project generator tool which will
allow us to do the following and much more in just a few clicks. For now, we can
create a new project with just a few small steps:</p>
<ol>
<li>
<p>Create the Rust project with the name of our project:</p>
<pre><code class="language-bash">cargo new my-project
</code></pre>
</li>
<li>
<p>Change directory to the generated project.</p>
<pre><code class="language-bash">cd my-project
</code></pre>
</li>
<li>
<p>Edit the <code>Cargo.toml</code> file and add the latest version of nannou to the bottom
like so:</p>
<pre><code class="language-toml">[package]
name = "my_project"
version = "0.1.0"
authors = ["mitchmindtree &lt;mitchell.nordine@gmail.com&gt;"]
edition = "2018"

[dependencies]
nannou = "0.17"
</code></pre>
<p>Note that there is a chance the nannou version above might be out of date.
You can check the latest version by typing <code>cargo search nannou</code> in your
terminal. Be sure to change the author to your name too!</p>
</li>
<li>
<p>Replace the code in <code>src/main.rs</code> with the following to setup our nannou
application.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate nannou;
</span>use nannou::prelude::*;

fn main() {
    nannou::app(model)
        .update(update)
        .simple_window(view)
        .run();
}

struct Model {}

fn model(_app: &amp;App) -&gt; Model {
    Model {}
}

fn update(_app: &amp;App, _model: &amp;mut Model, _update: Update) {
}

fn view(_app: &amp;App, _model: &amp;Model, frame: Frame) {
    frame.clear(PURPLE);
}</code></pre></pre>
<p>If you are new to Rust or simply do not understand the code above just yet,
do not fear! In the first tutorial of the next chapter we will break down
this code step-by-step.</p>
</li>
<li>
<p>Trigger the initial build and check that everything is working nicely by
running our app!</p>
<pre><code class="language-bash">cargo run --release
</code></pre>
<p>The first build might take a while, as we must build nannou and all of its
dependencies from scratch. The following times that we run our app should be
much faster!</p>
<p>Once the project has finished building, it will begin running and we should
be able to see a purple window.</p>
</li>
</ol>
<p><strong>That's it!</strong> If everything went as planned, you are now ready to start
building your own nannou project. Of course, we probably want our application to
be more than just a purple window.</p>
<p>To find out how to add more features to our project like graphics, audio,
multiple windows, laser output, projection mapping and much more, let's take a
look at the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating-nannou"><a class="header" href="#updating-nannou">Updating nannou</a></h1>
<p>You can update to a new version of nannou by editing your <code>Cargo.toml</code> file to
use the new crate. For version 0.12 add the line</p>
<pre><code class="language-toml">nannou = "0.12"
</code></pre>
<p>Then within the nannou directory run the following to update all dependencies:</p>
<pre><code class="language-bash">cargo update
</code></pre>
<h2 id="updating-rust"><a class="header" href="#updating-rust">Updating Rust.</a></h2>
<p>From time to time, a nannou update might require features from a newer version
of rustc. For example, nannou 0.12 is known to require at least rustc 1.35.0. In
these cases, you can update your rust toolchain to the latest version by running
the following:</p>
<pre><code class="language-bash">rustup update
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials-1"><a class="header" href="#tutorials-1">Tutorials</a></h1>
<p>In the previous chapter we prepared everything needed to start our own Nannou
project! In this chapter, we will take a more focused look at all of the
different features we can add to our Nannou project.</p>
<p>If you are new to Nannou or Rust we recommend starting with the "Basics"
tutorials before going on. If you are feeling more confident, feel free to
choose your own adventure through the following tutorials depending on what you
want to add to your project!</p>
<h2 id="rust-basics"><a class="header" href="#rust-basics">Rust Basics</a></h2>
<p>Tutorials for learning the basics of Rust with nannou.</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html">Rust variables</a></li>
<li><a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html">Rust control flows</a></li>
<li><a href="https://doc.rust-lang.org/book/ch03-03-how-functions-work.html">Rust functions</a></li>
</ul>
<h2 id="nannou-basics"><a class="header" href="#nannou-basics">Nannou Basics</a></h2>
<p>A suite of tutorials for getting familiar with the Nannou environment.</p>
<ul>
<li><a href="/tutorials/basics/anatomy-of-a-nannou-app.html">Anatomy of a nannou app</a></li>
<li><a href="/tutorials/basics/draw-a-sketch.html">Drawing a sketch</a></li>
<li><a href="/tutorials/basics/sketch-vs-app.html">Sketch vs App</a></li>
<li><a href="/tutorials/basics/window-coordinates.html">Window Coordinates</a></li>
<li>Nannou events</li>
</ul>
<h2 id="drawing"><a class="header" href="#drawing">Drawing</a></h2>
<p>Working with Nannou's <code>Draw</code> API - a simple approach of coding graphics.</p>
<ul>
<li><a href="/tutorials/draw/drawing-2d-shapes.html">Drawing 2D shapes</a></li>
<li><a href="/tutorials/draw/animating-a-circle.html">Animating a circle</a></li>
<li><a href="/tutorials/draw/drawing-images.html">Drawing images</a></li>
<li>Drawing 3D shapes</li>
<li>Drawing meshes</li>
</ul>
<h2 id="windowing"><a class="header" href="#windowing">Windowing</a></h2>
<p>Walk-throughs for creating and working with one or more windows.</p>
<ul>
<li>Building a custom window</li>
<li>Creating multiple windows</li>
<li>Drawing to different windows</li>
<li>Fullscreen on startup</li>
<li>Automatically positioning windows</li>
</ul>
<h2 id="gui"><a class="header" href="#gui">GUI</a></h2>
<p>How to create a GUI (Graphical User Interface) for you Nannou project.</p>
<p><em>NOTE: It might be best to wait for
<a href="https://github.com/nannou-org/nannou/issues/383">#383</a> before addressing
these.</em></p>
<ul>
<li>Creating a UI</li>
<li>Exploring available UI widgets</li>
<li>Multi-window UI</li>
</ul>
<h2 id="audio"><a class="header" href="#audio">Audio</a></h2>
<p>A suite of guides for working with audio in Nannou.</p>
<ul>
<li>Setting up audio output</li>
<li>Setting up audio input</li>
<li>Selecting specific audio devices</li>
<li>Playing an audio file</li>
<li>Basic audio synthesis</li>
<li>Many channel audio streams</li>
<li>Feeding audio input to output</li>
<li>Visualising audio</li>
</ul>
<h2 id="video"><a class="header" href="#video">Video</a></h2>
<p>Loading, playing and recording video in Nannou.</p>
<ul>
<li>Drawing video</li>
<li>Recording a window to video</li>
<li>Manipulating video playback</li>
</ul>
<h2 id="wgpu"><a class="header" href="#wgpu">WGPU</a></h2>
<p>Understanding the lower level that underlies all graphics in Nannou.</p>
<ul>
<li>What is WGPU?</li>
<li>The graphics pipeline</li>
<li>Compute shaders</li>
<li>Fragment shaders</li>
<li>Vertex shaders</li>
</ul>
<h2 id="projection-mapping"><a class="header" href="#projection-mapping">Projection Mapping</a></h2>
<p>Getting started with using Nannou for projection mapping.</p>
<ul>
<li>Basic quad-warping.</li>
</ul>
<h2 id="lasers"><a class="header" href="#lasers">LASERs</a></h2>
<p>Detecting and outputting to LASER DACs on a network.</p>
<ul>
<li>Connecting to a LASER.</li>
<li>Detecting LASER DACs.</li>
<li>Tweaking LASER interpolation and optimisations.</li>
</ul>
<h2 id="osc"><a class="header" href="#osc">OSC</a></h2>
<ul>
<li><a href="/tutorials/osc/osc-introduction.html">An intro to OSC</a>.</li>
<li><a href="/tutorials/osc/osc-sender.html">Sending OSC</a>.</li>
<li>Receiving OSC.</li>
</ul>
<h2 id="dmx"><a class="header" href="#dmx">DMX</a></h2>
<p>Working with DMX over the network via sACN.</p>
<ul>
<li>Working with the sacn crate.</li>
</ul>
<h2 id="serial-over-usb"><a class="header" href="#serial-over-usb">Serial over USB</a></h2>
<p>Working with Serial data in a cross-platform manner.</p>
<ul>
<li>Reading USB serial data.</li>
<li>Writing USB serial data.</li>
</ul>
<br>
<hr />
<p>If you were unable to find what you were looking for above, or if you have an
idea for a tutorial not yet present, please feel free to create an issue or a
pull request!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anatomy-of-a-nannou-app"><a class="header" href="#anatomy-of-a-nannou-app">Anatomy of a Nannou App</a></h1>
<p><strong>Tutorial Info</strong></p>
<ul>
<li>Author: tpltnt, mitchmindtree</li>
<li>Required Knowledge:
<ul>
<li><a href="tutorials/basics//getting_started.html">Getting Started</a></li>
</ul>
</li>
<li>Reading Time: 10 minutes</li>
</ul>
<hr />
<p><strong>Nannou is a framework for creative coding in Rust.</strong> A framework can be
thought of as a collection of building blocks that help accomplish a goal.
Let's take a look at the building blocks for creative coding together.</p>
<p>Here's an example of a bare-bones nannou app that opens an empty window:</p>
<pre><pre class="playground"><code class="language-rust no_run">use nannou::prelude::*;

struct Model {}

fn main() {
    nannou::app(model)
        .event(event)
        .simple_window(view)
        .run();
}

fn model(_app: &amp;App) -&gt; Model {
    Model {}
}

fn event(_app: &amp;App, _model: &amp;mut Model, _event: Event) {
}

fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
}</code></pre></pre>
<p>We will start from the top!</p>
<h2 id="import-common-items"><a class="header" href="#import-common-items">Import Common Items</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports)]
</span>use nannou::prelude::*;
<span class="boring">fn main() {}</span></code></pre></pre>
<p>This line imports all of the commonly used items from nannou into scope. These
include items such as <code>App</code>, <code>Frame</code>, and many more that we will learn about
over time. To see the full list of items re-exported by the prelude, see
<a href="https://docs.rs/nannou/latest/nannou/prelude/index.html">here</a>.</p>
<blockquote>
<p>Note: Unlike some other languages, Rust does not automatically include
everything from the libraries added to the project. This approach results in
very clean namespaces and avoids conflicts between different items from
different crates. That said, it also means we need to manually import every
item we <em>do</em> want to use into scope. By providing a prelude nannou makes it a
little easier to access all of the commonly used items.</p>
</blockquote>
<h2 id="model---our-app-state"><a class="header" href="#model---our-app-state"><strong>Model</strong> - Our app state</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span>struct Model {}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>The <strong>Model</strong> is where we define the state of our application. We can think of
the model as the representation of our program at any point in time. Throughout
the life of our program, we can update the model as certain events occur such as
mouse presses, key presses or timed updates. We can then present the model using
some kind of output, e.g. by drawing to the screen or outputting to a laser. We
will look at these input and output events in more detail in another tutorial!
Our example is as simple as possible, and we have no state to track. Thus our
model can stay empty.</p>
<blockquote>
<p>Note: A <code>struct</code> describes a set of data. Our struct has no fields and thus is
empty. There is no state information to be tracked in this example.</p>
</blockquote>
<h2 id="main---where-rust-programs-begin-and-end"><a class="header" href="#main---where-rust-programs-begin-and-end"><strong>main</strong> - Where Rust programs begin and end</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn main() {
    nannou::app(model)
        .event(event)
        .simple_window(view)
        .run();
}
<span class="boring">fn model(_app: &amp;App) -&gt; Model {
</span><span class="boring">    Model {}
</span><span class="boring">}
</span><span class="boring">fn event(_app: &amp;App, _model: &amp;mut Model, _event: Event) {
</span><span class="boring">}
</span><span class="boring">fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
</span><span class="boring">}</span></code></pre></pre>
<p>All Rust programs begin executing at the start of the <code>main</code> function and end
when the <code>main</code> function ends. In most nannou programs, the main function is
quite small. In short, we build a description of our app and then run it!</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span><span class="boring">fn main() {
</span>    nannou::app(model)       // Start building the app and specify our `model`
        .event(event)        // Specify that we want to handle app events with `event`
        .simple_window(view) // Request a simple window to which we'll draw with `view`
        .run();              // Run it!
<span class="boring">}
</span><span class="boring">fn model(_app: &amp;App) -&gt; Model {
</span><span class="boring">    Model {}
</span><span class="boring">}
</span><span class="boring">fn event(_app: &amp;App, _model: &amp;mut Model, _event: Event) {
</span><span class="boring">}
</span><span class="boring">fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
</span><span class="boring">}</span></code></pre></pre>
<p>We will describe what these <strong>model</strong>, <strong>event</strong> and <strong>view</strong> functions do
below!</p>
<blockquote>
<p>Note: In this app building process we get a hint at the fundamental design
archetype of nannou apps. The approach is roughly based on the
<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">Model-View-Controller (MVC)
pattern</a>,
though equally inspired by <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">Functional Reactive Programming
(FRP)</a>.</p>
<p>In general, these paradigms split a program into:</p>
<ul>
<li>a <strong>model</strong> describing the internal state</li>
<li>a <strong>view</strong> describing how to present the model and</li>
<li>a <strong>controller</strong> describing how to update the model on certain events.</li>
</ul>
<p>If you zoom out a bit you can think of the computer as a model, the screen as
a view, and the keyboard or mouse as the controller. A user looks at the view
and can change the state of the model using the controller. If a program does
not require <em>user</em> input, the controller might use time or some other
application event to modify the model.</p>
</blockquote>
<h2 id="model---initialise-our-model"><a class="header" href="#model---initialise-our-model"><strong>model</strong> - initialise our Model</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn model(_app: &amp;App) -&gt; Model {
    Model {}
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>The <code>model</code> function is run once at the beginning of the nannou app and produces
a fresh, new instance of the <strong>Model</strong> that we declared previously, AKA the app
state. This can be thought of as the "setup" stage of our application. Here, we
might do things like create some windows, create a GUI, load some images or
anything else that we want to happen once at the beginning of our program. We
will learn how to do all of these things in future tutorials, but for now we
will just return an instance of our empty <strong>Model</strong>.</p>
<blockquote>
<p>Note: To assist with the creation of windows, GUIs, audio streams and other
kinds of I/O, access to the <strong>App</strong> is provided as an <em>input</em> to the function.
The <strong>App</strong> type can be thought of as a helper type that wraps up the finicky
details of the application (such as establishing event loops, spawning I/O
streams, etc) and provides an easy to use, high-level API on top. Providing
access to the <strong>App</strong> via a function's first argument is a common practice
throughout nannou's API.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>//                ----- Access to the `App` passed as an input to the function.
//               /
//              v
fn model(_app: &amp;App) -&gt; Model {
    Model {}
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>You can learn more about what the <strong>App</strong> is responsible for and capable of
<a href="https://docs.rs/nannou/latest/nannou/app/struct.App.html">here</a>.</p>
</blockquote>
<h2 id="event---updating-the-model-on-app-events"><a class="header" href="#event---updating-the-model-on-app-events"><strong>event</strong> - updating the Model on app events</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn event(_app: &amp;App, _model: &amp;mut Model, _event: Event) {
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>The <strong>event</strong> function is some code that will run every time some kind of app
event occurs. There are many different kinds of app events including mouse and
keyboard presses, window resizes, timed updates and many more. Each of these are
events during which we may wish to update our <strong>Model</strong> in some way. For
example, we may wish to turn a camera when a mouse is moved, begin drawing a
shape when a button is pressed, or step forward an animation on timed updates.</p>
<p>All of these events are described within the <strong>Event</strong> type. One way to
distinguish between which event is currently occurring is to <a href="https://doc.rust-lang.org/book/ch06-02-match.html">"pattern
match"</a> on the event and
handle only those events that we care about, ignoring all the others. A simpler
approach is to not register an <strong>event</strong> function while building the app at all,
and instead only register more specific functions for those events that we care
about.</p>
<p>For example, if instead of handling <em>all</em> events we only want to handle timed
updates (an event that by default occurs 60 times per second) we could change
our app building code to this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn main() {
    nannou::app(model)
        .update(update) // rather than `.event(event)`, now we only subscribe to updates
        .simple_window(view)
        .run();
}
<span class="boring">fn model(_app: &amp;App) -&gt; Model {
</span><span class="boring">    Model {}
</span><span class="boring">}
</span><span class="boring">fn update(_app: &amp;App, _model: &amp;mut Model, _update: Update) {
</span><span class="boring">}
</span><span class="boring">fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
</span><span class="boring">}</span></code></pre></pre>
<p>And remove our <code>event</code> function in favour of an <code>update</code> function:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn update(_app: &amp;App, _model: &amp;mut Model, _update: Update) {
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Now, our new <strong>update</strong> function will only run each time a timed update
occurs.</p>
<blockquote>
<p>Note: Nannou provides a whole suite of different events that may be registered
while building an app or window in this way. See the <a href="https://github.com/nannou-org/nannou/blob/master/examples/nannou_basics/all_functions.rs">all_functions.rs
example</a>
for a demonstration of most of the different kinds of events that are
available.</p>
</blockquote>
<h2 id="view---presenting-the-model-to-a-window"><a class="header" href="#view---presenting-the-model-to-a-window"><strong>view</strong> - presenting the Model to a window</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {}
</span>fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Finally, the <strong>view</strong> allows us to present the state of the model to a window by
drawing to its <strong>Frame</strong> and returning the frame at the end. Here we can change
the background colour, use the <strong>Draw</strong> API to draw a scene, draw a GUI to the
window or even use the wgpu API to draw to the frame using our own textures and
render passes. All of this will be covered by future tutorials.</p>
<h2 id="concluding-remarks"><a class="header" href="#concluding-remarks">Concluding Remarks</a></h2>
<p>Hopefully this has given you a rough idea of how nannou apps work! Do not stress
if some of the syntax looks confusing or some of the specifics still seem
unclear - we will aim to cover these and more in future tutorials :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="draw-a-sketch"><a class="header" href="#draw-a-sketch">Draw a Sketch</a></h1>
<p><strong>Tutorial Info</strong></p>
<ul>
<li>Author: tpltnt</li>
<li>Required Knowledge:
<ul>
<li><a href="tutorials/basics//getting_started.html">Getting Started</a></li>
</ul>
</li>
<li>Reading Time: 5 minutes</li>
</ul>
<hr />
<p><strong>Nannou is a framework for creative coding in Rust.</strong> A framework can be
thought of as a collection of building blocks to help accomplish a goal.
A sketch is the smallest/fastest way to get results with nannou.
Here is one example which just yields a blue window:</p>
<pre><pre class="playground"><code class="language-rust no_run">use nannou::prelude::*;

fn main() {
    nannou::sketch(view).run();
}

fn view(app: &amp;App, frame: Frame) {
    // get canvas to draw on
    let draw = app.draw();

    // set background to blue
    draw.background().color(BLUE);

    // put everything on the frame
    draw.to_frame(app, &amp;frame).unwrap();
}</code></pre></pre>
<p>You can exit the sketch by pressing <code>ESC</code>.</p>
<h2 id="explaining-the-code"><a class="header" href="#explaining-the-code">Explaining the Code</a></h2>
<p>A sketch consists of at least two functions: <code>main()</code> and <code>view()</code>.
First we import some building blocks:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports)]
</span>use nannou::prelude::*;
<span class="boring">fn main() {}</span></code></pre></pre>
<p>After this import the actual sketching code starts. The <code>main()</code> functions is where all your logic starts. The code</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use nannou::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    nannou::sketch(view).run();
<span class="boring">}
</span><span class="boring">fn view(_app: &amp;App, _frame: Frame) {}</span></code></pre></pre>
<p>calls a function to draw on the single window (<code>view()</code> in this case). This
function has the signature <code>fn(_: &amp;App, _: Frame);</code>. Don't worry if you
don't know what a function signature is. Just copy the <code>main()</code> function
and you will be fine.</p>
<p>Within the view() function, what we draw to the Frame will be presented in our window.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">   nannou::sketch(view).run();
</span><span class="boring">}
</span>fn view(app: &amp;App, frame: Frame) {
    let draw = app.draw();

    draw.background().color(BLUE);

    draw.to_frame(app, &amp;frame).unwrap();
}</code></pre></pre>
<p>This function follows the same scheme. First some setup is done. The line</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">   nannou::sketch(view).run();
</span><span class="boring">}
</span><span class="boring">fn view(app: &amp;App, _frame: Frame) {
</span>let draw = app.draw();
<span class="boring">}</span></code></pre></pre>
<p>lets us assign a canvas-like datatype to the variable <code>draw</code>.
We can now paint on the this canvas by setting the background to blue.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">   nannou::sketch(view).run();
</span><span class="boring">}
</span><span class="boring">fn view(app: &amp;App, _frame: Frame) {
</span><span class="boring">let draw = app.draw();
</span>draw.background().color(BLUE);
<span class="boring">}</span></code></pre></pre>
<p>Now we have a canvas with only a blue background. We take this canvas and
create a computer graphics frame from it to display in the main window.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">   nannou::sketch(view).run();
</span><span class="boring">}
</span><span class="boring">fn view(app: &amp;App, frame: Frame) {
</span><span class="boring">let draw = app.draw();
</span>draw.to_frame(app, &amp;frame).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>If you find the desire to respond to other kinds of events, interact with other
kinds of input/output, track some state, or need more flexibility in general,
you might be interested in creating a <a href="tutorials/basics/./anatomy-of-a-nannou-app.html">nannou app</a>
instead! You can also learn more about the difference between sketches and apps
<a href="tutorials/basics/./sketch-vs-app.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics---sketch-vs-app"><a class="header" href="#basics---sketch-vs-app">Basics - <code>sketch</code> vs <code>app</code></a></h1>
<p><strong>Tutorial Info</strong></p>
<ul>
<li>Author: mitchmindtree</li>
<li>Required Knowledge:
<ul>
<li><a href="tutorials/basics//getting_started.html">Getting Started</a></li>
</ul>
</li>
<li>Reading Time: 7 minutes</li>
</ul>
<hr />
<p>When creating a new nannou project we have two options for kicking off our
program:</p>
<ol>
<li><code>nannou::sketch</code> and</li>
<li><code>nannou::app</code>.</li>
</ol>
<p>Let's find out exactly what the differences are!</p>
<blockquote>
<p><strong>Note:</strong> When referring to <em>app</em> throughout this tutorial, we are referring to
a nannou project that is run via <code>nannou::app</code>. We are <em>not</em> referring to the
<code>App</code> type that often appears as the first argument in nannou functions.
Hopefully we can point to an <code>App</code> oriented tutorial some day soon!</p>
</blockquote>
<h2 id="sketches"><a class="header" href="#sketches">Sketches</a></h2>
<p><strong>Sketches</strong> are perfect for quick doodles and casual creations. They only
require a simple <code>view</code> function designed to make it easy to start drawing
quickly and easily.</p>
<p>Here is what the <a href="https://github.com/nannou-org/nannou/blob/master/examples/templates/template_sketch.rs">sketch
template</a>
looks like:</p>
<pre><pre class="playground"><code class="language-rust no_run">use nannou::prelude::*;

fn main() {
    nannou::sketch(view).run()
}

fn view(app: &amp;App, frame: Frame) {
    let draw = app.draw();
    draw.background().color(PLUM);
    draw.ellipse().color(STEELBLUE);
    draw.to_frame(app, &amp;frame).unwrap();
}</code></pre></pre>
<p>While you cannot update or track any custom state, we still have access to
plenty of fun inputs including time, the state of the keyboard, mouse and more.</p>
<h2 id="apps"><a class="header" href="#apps">Apps</a></h2>
<p><strong>Apps</strong> are better suited to more sophisticated artworks or even fully fledged
applications. They allow for greater flexibility and finer grained control than
sketches, but also require a little more setup.</p>
<p>Here is what the <a href="https://github.com/nannou-org/nannou/blob/master/examples/templates/template_app.rs">app
template</a>
looks like:</p>
<pre><pre class="playground"><code class="language-rust no_run">use nannou::prelude::*;

fn main() {
    nannou::app(model).update(update).run();
}

struct Model {
    _window: window::Id,
}

fn model(app: &amp;App) -&gt; Model {
    let _window = app.new_window().view(view).build().unwrap();
    Model { _window }
}

fn update(_app: &amp;App, _model: &amp;mut Model, _update: Update) {}

fn view(app: &amp;App, _model: &amp;Model, frame: Frame) {
    let draw = app.draw();
    draw.background().color(PLUM);
    draw.ellipse().color(STEELBLUE);
    draw.to_frame(app, &amp;frame).unwrap();
}</code></pre></pre>
<p>More specifically, the primary difference is that an app allows for working with
custom <em><strong>state</strong></em> (i.e. the <code>Model</code>), whereas a sketch does not.</p>
<blockquote>
<p><em><strong>Hot tip!</strong></em></p>
<p>The line:</p>
<pre><code class="language-rust ignore">nannou::sketch(view).run()</code></pre>
<p>is simply short-hand for</p>
<pre><code class="language-rust ignore">nannou::app(model).simple_window(view).run()</code></pre>
<p>except without the need for <code>model</code> and with a slightly simpler <code>view</code> function.</p>
</blockquote>
<h2 id="switching-from-sketch-to-app"><a class="header" href="#switching-from-sketch-to-app">Switching from <code>sketch</code> to <code>app</code></a></h2>
<p>In the end it does not make a great deal of difference what you choose, you can
always switch from one to the other in the middle of a project!</p>
<p>If your sketch is getting particularly fancy and you would like to add some more
flexibility, you can turn it into an app by following these steps:</p>
<ol>
<li>
<p>Change your <code>main</code> function from</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span>nannou::sketch(view).run()
<span class="boring">}
</span><span class="boring">fn view(_: &amp;App, _: Frame) {}</span></code></pre></pre>
<p>to</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span>nannou::app(model).simple_window(view).run()
<span class="boring">}
</span><span class="boring">struct Model {}
</span><span class="boring">fn model(_: &amp;App) -&gt; Model { Model {} }
</span><span class="boring">fn view(_: &amp;App, _: &amp;Model, _: Frame) {}</span></code></pre></pre>
</li>
<li>
<p>Add a <code>Model</code> for tracking state:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span>struct Model {}</code></pre></pre>
</li>
<li>
<p>Add a <code>model</code> function for creating the <code>Model</code>:</p>
<pre><pre class="playground"><code class="language-rust no_Run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {}
</span><span class="boring">struct Model {}
</span>fn model(_app: &amp;App) -&gt; Model {
    Model {}
}</code></pre></pre>
</li>
<li>
<p>Change the <code>view</code> function signature from:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {}
</span>fn view(app: &amp;App, frame: Frame) {
<span class="boring">}</span></code></pre></pre>
<p>to</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {}
</span><span class="boring">struct Model {}
</span>fn view(app: &amp;App, _model: &amp;Model, frame: Frame) {
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<p>And that's it! You are now ready to take your sketch to the next level.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th><strong>Sketch</strong></th><th><strong>App</strong></th></tr></thead><tbody>
<tr><td>Easier to start drawing quickly?</td><td>Yes</td><td>No</td></tr>
<tr><td>Allows for a <code>Model</code>?</td><td>No</td><td>Yes</td></tr>
<tr><td>Allows for  audio/LASER/MIDI/etc?</td><td>No</td><td>Yes</td></tr>
<tr><td>The <code>main</code> function looks like:</td><td><code>nannou::sketch(view)</code></td><td><code>nannou::app(model)</code></td></tr>
<tr><td>Templates</td><td><a href="https://github.com/nannou-org/nannou/blob/master/examples/templates/template_sketch.rs">template_sketch.rs</a></td><td><a href="https://github.com/nannou-org/nannou/blob/master/examples/templates/template_app.rs">template_app.rs</a></td></tr>
<tr><td>Can make awesome stuff?</td><td>Yes</td><td>Yes</td></tr>
</tbody></table>
</div>
<p>To learn more about nannou <strong>sketches</strong> visit the <a href="tutorials/basics//tutorials/basics/draw-a-sketch.html">Draw a sketch</a> tutorial.</p>
<p>To learn more about nannou <strong>apps</strong> visit the <a href="tutorials/basics//tutorials/basics/anatomy-of-a-nannou-app.html">Anatomy of a nannou app</a> tutorial.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics---window-coordinates"><a class="header" href="#basics---window-coordinates">Basics - Window Coordinates</a></h1>
<p><strong>Tutorial Info</strong></p>
<ul>
<li>Author: mitchmindtree</li>
<li>Required Knowledge:
<ul>
<li><a href="tutorials/basics//getting_started.html">Getting Started</a></li>
</ul>
</li>
<li>Reading Time: 15 minutes</li>
</ul>
<hr />
<p><strong>Coordinates</strong> can be used to describe a position in space. Before we start
drawing things in certain locations within our window, or animating them to move
in certain directions, it can be very useful to understand the <strong>coordinate
system</strong> that we are working with.</p>
<p>Different kinds of coordinate systems are useful for different purposes. Let's
take a look at nannou's <strong>window coordinates</strong>.</p>
<p><img src="tutorials/basics/./images/window_coordinates_example.png" alt="window_coordinates.rs" /></p>
<p>This is a screenshot of the <a href="https://github.com/nannou-org/nannou/tree/master/examples/nannou_basics/window_coordinates.rs"><code>window_coordinates.rs</code> example</a>. The example
aims to help develop an intuition for how nannou's window coordinates work. In
this case, we are presented with a window whose size is 600x400. We can see
that:</p>
<ul>
<li>The <strong>x</strong> and <strong>y</strong> values are <strong><code>[0.0, 0.0]</code></strong> in the <strong>centre</strong> of the
window. This is called the <em>origin</em>.</li>
<li>The <strong>x</strong> value <strong>increases towards the right</strong> and <strong>decreases towards the
left</strong>.</li>
<li>The <strong>y</strong> value <strong>increases upwards</strong> and <strong>decreases downwards</strong>.</li>
<li>The distance from the left edge to the right edge is 600, equal to the window
width.</li>
<li>The distance from the bottom edge to the top edge is 400, equal to the window
height.</li>
<li>The distance from the centre to the left or right edge is 300, or half the
window width.</li>
<li>The distance from the centre to the top or bottom edge is 200, or half the
window height.</li>
</ul>
<p>In other words, nannou uses a <a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system">Cartesian coordinate system</a> to describe
window space, where the origin is in the centre, <em>y</em> increases upwards and the
distance between the edges of the window are equal to the size of the window.</p>
<h2 id="drawing-in-window-coordinates"><a class="header" href="#drawing-in-window-coordinates">Drawing in Window Coordinates</a></h2>
<p>Having the origin in the centre is a theme that carries through to the way that
we draw shapes with nannou's <a href="https://guide.nannou.cc/tutorials.html#drawing"><code>draw</code> API</a>. Let's see what happens if we
change the example to draw a plum colored square at <code>[0.0, 0.0]</code> and with a size
of <code>100.0</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>draw.rect()
    .x_y(0.0, 0.0)
    .w_h(100.0, 100.0)
    .color(PLUM);
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/basics/./images/window_coordinates_example2.png" alt="window_coordinates.rs" /></p>
<p>Notice that when we say <code>.x_y(0.0, 0.0)</code>, this refers to where the <strong>centre</strong> of
the square will be placed. You might notice the same applies to other drawing
primitives like ellipse and text.</p>
<h3 id="rotating-the-square"><a class="header" href="#rotating-the-square">Rotating the square</a></h3>
<p>This property of describing positions via the centre allows for performing all
kinds of symmetrical operations with ease. Rotations are a nice example of this.
Let's try rotating our plum square by 45 degrees.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>draw.rect()
    .x_y(0.0, 0.0)
    .w_h(100.0, 100.0)
    .z_degrees(45.0)
    .color(PLUM);
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/basics/./images/window_coordinates_example3.png" alt="window_coordinates.rs" /></p>
<p>Voila!</p>
<h3 id="moving-the-square"><a class="header" href="#moving-the-square">Moving the square</a></h3>
<p>OK, now let's remove our rotation and try positioning the square so that the
bottom left corner touches the origin while the top right corner touches the
<code>[100.0, 100.0]</code> marker.</p>
<p>In order to do this, we want to move the square so that it is halfway between
the origin and the marker, so <code>[50.0, 50.0]</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>draw.rect()
    .x_y(50.0, 50.0)
    .w_h(100.0, 100.0)
    .color(PLUM);
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/basics/./images/window_coordinates_example4.png" alt="window_coordinates.rs" /></p>
<p>So satisfying!</p>
<p><em>OK, but what if we want to position our square in the top-left corner of the
window?</em></p>
<p>One approach would be to calculate the position by hand. For example, we know
the top-left corner is equal to [-300, 200]. From there, we need to move the
square to the right by half the width and down by half the height:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>let side = 100.0;
let top_left = pt2(-300.0, 200.0);
let offset = vec2(side / 2.0, -side / 2.0);
let xy = top_left + offset;
draw.rect()
    .xy(xy)
    .w_h(side, side)
    .color(PLUM);
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/basics/./images/window_coordinates_example5.png" alt="window_coordinates.rs" /></p>
<p>OK that worked! But it was a <strong>lot</strong> of effort. And what if the size of the
window changes?</p>
<p>Enter, <strong><code>Rect</code></strong>.</p>
<h2 id="positioning-with-rect"><a class="header" href="#positioning-with-rect">Positioning with <code>Rect</code></a></h2>
<p>One of the most useful tools for working in window coordinates is <a href="https://docs.rs/nannou/latest/nannou/geom/rect/struct.Rect.html">the <code>Rect</code>
type</a>. As the name suggests, <code>Rect</code> allows us to work with rectangles in a
variety of useful ways. We can <a href="https://docs.rs/nannou/latest/nannou/geom/rect/struct.Rect.html#method.align_left_of">align</a> them, <a href="https://docs.rs/nannou/latest/nannou/geom/rect/struct.Rect.html#method.pad">pad</a> them, <a href="https://docs.rs/nannou/latest/nannou/geom/rect/struct.Rect.html#method.shift">shift</a>
them, <a href="https://docs.rs/nannou/latest/nannou/geom/rect/struct.Rect.html#method.stretch_to_point">stretch</a> them, <a href="https://docs.rs/nannou/latest/nannou/geom/rect/struct.Rect.html#method.subdivisions_iter">subdivide</a> them, check if they <a href="https://docs.rs/nannou/latest/nannou/geom/rect/struct.Rect.html#method.contains">contain a
point</a> and more.</p>
<p>One of the most useful applications of <code>Rect</code> is for describing the bounds of
the window. Let's retrieve the window <code>Rect</code> with the name <code>win</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let app: App = unimplemented!();
</span>let win = app.window_rect();
<span class="boring">}</span></code></pre></pre>
<p>Let's use <code>win</code> to simplify aligning our plum square to the top left of the
window.</p>
<h3 id="alignment"><a class="header" href="#alignment">Alignment</a></h3>
<p>First, let's make a <code>Rect</code> that represents the position and size of our plum
square and call it <code>r</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span>let r = Rect::from_w_h(100.0, 100.0);
<span class="boring">}</span></code></pre></pre>
<p><code>r</code> now represents our square, positioned at [0.0, 0.0] with a width and height
of 100.0. We can confirm this by changing our square drawing code to use <code>r</code>
like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>let r = Rect::from_w_h(100.0f32, 100.0f32);
draw.rect()
    .xy(r.xy())
    .wh(r.wh())
    .color(PLUM);
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/basics/./images/window_coordinates_example2.png" alt="window_coordinates.rs" /></p>
<p>We can align our plum square to the <code>top_left_of</code> the window like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span><span class="boring">    let win: Rect = unimplemented!();
</span>let r = Rect::from_w_h(100.0, 100.0).top_left_of(win);
draw.rect()
    .xy(r.xy())
    .wh(r.wh())
    .color(PLUM);
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/basics/./images/window_coordinates_example5.png" alt="window_coordinates.rs" /></p>
<p>Much nicer!</p>
<p><em>But what if we want some padding between the edges of the window and the
square?</em></p>
<p>Let's take a look!</p>
<h3 id="padding"><a class="header" href="#padding">Padding</a></h3>
<p>We can use padding to add some space between the edges of an area and the
content within it. In nannou, we can use the <code>pad</code> method to produce a padded
instance of a <code>Rect</code>.</p>
<p>Let's try padding the window rect by <code>25.0</code> and drawing it with a
semi-transparent blue color:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span><span class="boring">    let win: Rect = unimplemented!();
</span>let win_p = win.pad(25.0);
draw.rect()
    .xy(win_p.xy())
    .wh(win_p.wh())
    .color(rgba(0.3, 0.4, 0.7, 0.5));
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/basics/./images/window_coordinates_example6.png" alt="window_coordinates.rs" /></p>
<p>As you may have guessed, we can use this new padded <code>Rect</code> to align our plum
square and achieve the desired look:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span><span class="boring">    let win: Rect = unimplemented!();
</span>let win_p = win.pad(25.0);
let r = Rect::from_w_h(100.0, 100.0).top_left_of(win_p);
draw.rect()
    .xy(r.xy())
    .wh(r.wh())
    .color(PLUM);
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/basics/./images/window_coordinates_example7.png" alt="window_coordinates.rs" /></p>
<h3 id="relative-positions"><a class="header" href="#relative-positions">Relative Positions</a></h3>
<p>Now that we have our plum square situated with some nice padding in the top left
corner, let's try drawing a salmon colored circle with the same size right below
it.</p>
<p>Our handy <code>Rect</code> type provides methods for positioning <code>below</code>, <code>above</code>,
<code>left_of</code> and <code>right_of</code> another <code>Rect</code>. Let's use the <code>below</code> method on a copy
of the square's <code>Rect</code> so that we can use the resulting <code>Rect</code> to draw our
circle:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span><span class="boring">    let win: Rect = unimplemented!();
</span>let win_p = win.pad(25.0);
let square = Rect::from_w_h(100.0, 100.0).top_left_of(win_p);
draw.rect()
    .xy(square.xy())
    .wh(square.wh())
    .color(PLUM);

let circle = square.below(square);
draw.ellipse()
    .xy(circle.xy())
    .wh(circle.wh())
    .color(SALMON);
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/basics/./images/window_coordinates_example8.png" alt="window_coordinates.rs" /></p>
<p>For consistency, let's try and add the same padding between the circle and the
square as we have between the square and the edges of the window.</p>
<p>We can do so by using the <code>shift</code> method to "shift" the circle down from the
square:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span><span class="boring">    let win: Rect = unimplemented!();
</span>let pad = 25.0;
let win_p = win.pad(pad);
let square = Rect::from_w_h(100.0, 100.0).top_left_of(win_p);
draw.rect()
    .xy(square.xy())
    .wh(square.wh())
    .color(PLUM);

let circle = square.below(square).shift_y(-pad);
draw.ellipse()
    .xy(circle.xy())
    .wh(circle.wh())
    .color(SALMON);
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/basics/./images/window_coordinates_example9.png" alt="window_coordinates.rs" /></p>
<p><em>Gee wizz, I love salmon!</em></p>
<p>There are many more fancy tricks we can do with <code>Rect</code> to assist as a guide for
laying out our sketches. I'm already getting carried away, so I'll leave it as
an exercise to the reader to check out <a href="https://docs.rs/nannou/latest/nannou/geom/rect/struct.Rect.html">the <code>Rect</code> docs</a> and explore!</p>
<p>Before we bring this tutorial to a close, let's take a quick look at what we
really mean by all these numbers.</p>
<h2 id="points-and-pixels"><a class="header" href="#points-and-pixels">Points and Pixels</a></h2>
<p><em>What exactly does 600x400 measure? Millimetres? Pixels? Something
else?</em></p>
<p>In nannou, we generally describe positions within window space in <strong>points</strong>.
Points are very similar to <strong>pixels</strong>, except that points allow us to work
without having to worry about the "scale factor" of our display.</p>
<blockquote>
<p><em><strong>Wait, what is "scale factor"?</strong></em></p>
<p>The scale factor helps us to reason about the density of pixels on the
display. Modern displays don't have a consistent relationship between
resolution and size. For example, modern mobile phones can boast resolutions
of up to 1440p, which is greater than the average 1080p desktop monitor,
despite the screen being a fraction of the size!</p>
<p>For this reason, most devices expose a <strong>scale factor</strong>. This value describes
the recommended UI scaling that should be applied in order to allow for a
consistent user experience across devices. In nannou, we refer to this scaled
space as <em>points</em> (aka <em>logical pixels</em>) and the <em>physical</em> pixel space as
<em>pixels</em>. By working in <em>points</em> we can let nannou take care of scaling for
us.</p>
<p>You can learn more about how window scaling works in nannou's windowing
library <a href="https://docs.rs/winit/latest/winit/dpi/index.html">here</a>.</p>
<p>To convert from points to pixels we can multiply by the scale factor:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let points = 100.0;
</span><span class="boring">    let window: Window = unimplemented!();
</span>let pixels = points * window.scale_factor();
<span class="boring">}</span></code></pre></pre>
<p>Similarly, we can convert pixels to points by dividing by the scale factor:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let pixels = 100.0;
</span><span class="boring">    let window: Window = unimplemented!();
</span>let points = pixels / window.scale_factor();
<span class="boring">}</span></code></pre></pre>
</blockquote>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Thanks for reading! Hopefully this has helped to demystify window coordinates in
nannou at least a little.</p>
<p>Remember, the more you experiment and play, the more these things become second
nature. Next thing you know you will start seeing everything in window
coordinates!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawing-2d-shapes"><a class="header" href="#drawing-2d-shapes">Drawing 2D Shapes</a></h1>
<p><strong>Tutorial Info</strong></p>
<ul>
<li>Author: Seth Boyles</li>
<li>Required Knowledge:
<ul>
<li><a href="tutorials/draw//getting_started.html">Getting Started</a></li>
<li><a href="tutorials/draw/./draw-a-sketch.html">Draw a Sketch</a></li>
</ul>
</li>
<li>Reading Time: 20 minutes</li>
</ul>
<hr />
<p>In this tutorial we explore drawing 2D shapes with nannou. We will cover drawing
basic lines, simple polygons (e.g. ellipses, rectangles, etc.), and more complex
polygons where you can create whatever shape you'd like!</p>
<p>To begin with, we will need a nannou project file to work with. Copy the
following into new file:</p>
<pre><pre class="playground"><code class="language-rust no_run">use nannou::prelude::*;

fn main() {
    nannou::sketch(view).run();
}

fn view(app: &amp;App, frame: Frame) {
    // Prepare to draw.
    let draw = app.draw();

    // Clear the background to purple.
    draw.background().color(PLUM);

    // Draw a blue ellipse with default size and position.
    draw.ellipse().color(STEELBLUE);

    // Write to the window frame.
    draw.to_frame(app, &amp;frame).unwrap();
}</code></pre></pre>
<p>You can also find this file, and other useful examples, in the <a href="https://github.com/nannou-org/nannou/tree/master/examples">examples</a> directory of the nannou source repository.</p>
<h2 id="drawing-simple-shapes"><a class="header" href="#drawing-simple-shapes">Drawing Simple Shapes</a></h2>
<p>Let's try running the file!  (if you haven't already, you will need to add this file to your Cargo.toml file)</p>
<p>You should a new window with something that looks like this:</p>
<p><img src="tutorials/draw/./images/2d-shape-circle.png" alt="A simple circle" /></p>
<p>Already we are rendering a circle to our canvas.  As you may have guessed, the line of code responsible for creating a circle is the call to the <code>ellipse</code> function:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>draw.ellipse()
    .color(STEELBLUE);
<span class="boring">}</span></code></pre></pre>
<p>There are many ways we can alter our circle here.  Let's start with changing the size:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>draw.ellipse()
    .color(STEELBLUE)
    .w(300.0)
    .h(200.0);
<span class="boring">}</span></code></pre></pre>
<p>The <code>w</code> function here changes the width of the ellipse to 300 pixels, and the <code>h</code> function changes the height to 200.0 pixels. You should see what we would more colloquially refer to as an ellipse.</p>
<p>We can also change the position of our ellipse with the <code>x_y</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>draw.ellipse()
    .color(STEELBLUE)
    .w(300.0)
    .h(200.0)
    .x_y(200.0, -100.0);
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/draw/./images/2d-shape-ellipse.png" alt="An ellipse" /></p>
<p>As you can see, we edit our ellipse by chaining together different methods which will change one or more properties of our shape.  This is called the <strong>Builder</strong> pattern.  The call to <code>draw.ellipse()</code> returns an object of type <code>Drawing&lt;Ellipse&gt;</code>.  In turn, each call to a builder method, such as <code>w(300.0)</code> or <code>x_y(200.0, -100.0)</code>, returns the same instance of our shape. By chaining these function calls, we are able to build an ellipse with the attributes we want.</p>
<p>There are several more methods we can use to build our ellipse. You can view the documentation for many of these methods <a href="https://docs.rs/nannou/latest/nannou/draw/struct.Drawing.html">here</a>.</p>
<h3 id="drawing-rectangles-and-quadrilaterals"><a class="header" href="#drawing-rectangles-and-quadrilaterals">Drawing Rectangles and Quadrilaterals</a></h3>
<p>Drawing a square or rectangle uses the same builder pattern that drawing an ellipse does.  In fact, it's similar enough that you can swap out <code>ellipse</code> with <code>rect</code> in the example above to get a working example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>draw.rect()
    .color(STEELBLUE)
    .w(300.0)
    .h(200.0);
<span class="boring">}</span></code></pre></pre>
<p>You will see an image like this:</p>
<p><img src="tutorials/draw/./images/2d-shape-rect.png" alt="A rectangle" /></p>
<p>In addition to <code>rect</code>, you can also use the <code>quad</code> method, which is for drawing quadrilaterals. This function is similar to <code>rect</code>, but you can also choose to supply your own coordinates for your shape.  Try the following:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>let point1 = pt2(-10.0, -20.0);
let point2 = pt2(10.0, -30.0);
let point3 = pt2(15.0, 40.0);
let point4 = pt2(-20.0, 35.0);

draw.quad()
    .color(STEELBLUE)
    .w(300.0)
    .h(200.0)
    .points(point1, point2, point3, point4);
<span class="boring">}</span></code></pre></pre>
<p>You should see the following:</p>
<p><img src="tutorials/draw/./images/2d-shape-quad.png" alt="A quadrilateral with custom defined points" /></p>
<p>The <code>pt2</code> method above will create a point object that represents a point in XY coordinate space, like a graph or a Cartesian plane. nannou's coordinate system places (0,0) at the center of the window. This is <strong>not</strong> like many other graphical creative coding frameworks, which place (0,0) at the upper-leftmost position of the window.</p>
<p>Note that while the <code>Drawing</code> builder objects for different shapes share many of the same builder methods, they do not share all of them.  Trying to use the method <code>points</code> on an instance of an <code>Drawing&lt;Ellipse&gt;</code>, for example, will raise an error.</p>
<h3 id="drawing-a-triangle"><a class="header" href="#drawing-a-triangle">Drawing a Triangle</a></h3>
<p>Additionally, there is one more simple shape method: <code>tri</code>, for drawing triangles.  It behaves similarly to <code>quad</code>, where you can supply your own coordinates to decide how the shape looks.  Try it out!</p>
<p><img src="tutorials/draw/./images/2d-shape-tri.png" alt="A triangle" /></p>
<h2 id="drawing-lines"><a class="header" href="#drawing-lines">Drawing Lines</a></h2>
<p>The <code>line</code> function provides a simple way to draw a line:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>let start_point = pt2(-30.0, -20.0);
let end_point   = pt2(40.0, 40.0);

draw.line()
    .start(start_point)
    .end(end_point)
    .weight(4.0)
    .color(STEELBLUE);
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/draw/./images/2d-simple-line.png" alt="A simple line" /></p>
<p>Simply provide a starting point and an ending point, and you have your line.</p>
<p>This is great for simpler drawings, but what if you want to draw something more complicated? A sine wave, for instance.</p>
<p>To draw our sine wave, we will use the <code>polyline</code> function.  To use this function, we will supply a collection (or array) of points that represent points on a sine wave.  We can generate this array of points using—what else—the <code>sin</code> function!</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>let points = (0..50).map(|i| {
  let x = i as f32 - 25.0;          //subtract 25 to center the sine wave
  let point = pt2(x, x.sin()) * 20.0; //scale sine wave by 20.0
  (point, STEELBLUE)
});
draw.polyline()
    .weight(3.0)
    .points_colored(points);
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/draw/./images/2d-simple-polyline.png" alt="A sine wave polyline drawing" /></p>
<p>As you can see, the power of <code>polyline</code> is the ability to draw a series of lines
connecting and ordered array of points.  With this, you can easily draw a
variety of shapes or lines, so long as you can provide or generate the points
you need to represent that shape.</p>
<p>For example, a circle:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>// Store the radius of the circle we want to make.
let radius = 150.0;
// Map over an array of integers from 0 to 360 to represent the degrees in a circle.
let points = (0..=360).map(|i| {
    // Convert each degree to radians.
    let radian = deg_to_rad(i as f32);
    // Get the sine of the radian to find the x co-ordinate of this point of the circle
    // and multiply it by the radius.
    let x = radian.sin() * radius;
    // Do the same with cosine to find the y co-ordinate.
    let y = radian.cos() * radius;
    // Construct and return a point object with a color.
    (pt2(x,y), STEELBLUE)
});
// Create a polyline builder. Hot-tip: polyline is short-hand for a path that is
// drawn via "stroke" tessellation rather than "fill" tessellation.
draw.polyline()
    .weight(3.0)
    .points_colored(points); // Submit our points.
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/draw/./images/2d-custom-circle-outline.png" alt="A custom circle" /></p>
<p>A custom drawn circle! ...okay, perhaps this isn't too exciting, given that we
already have an easy way of drawing circles with <code>ellipse</code>. But with a simple
change to the above code we can generate an outline of a different shape. Let's
try using the <code>step_by</code> function, which allows us to choose the interval at
which we would like to step through a range or other iterator. So instead of
calling <code>(0..=360).map</code>, we will call <code>(0..=360).step_by(45).map</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let points = (0..=360).step_by(45).map(|i| {
<span class="boring">    0.0
</span><span class="boring">});
</span><span class="boring">}</span></code></pre></pre>
<p>The rest of our code will remain unchanged.</p>
<p>Because 45 divides into 360 eight times, our code generated 8 points to represent a regular octagon.</p>
<p><img src="tutorials/draw/./images/2d-complete-octogon-outline.png" alt="An octagon outline" /></p>
<p>An octagon!</p>
<p>Try experimenting with different values to pass into <code>step_by</code> and see the
different shapes you can create!</p>
<p>As a side note, you may have noticed that we did not use a <code>color</code> function to
set the drawing's color this time. Instead, <code>polyline</code> allows for each point to
be colored uniquely. This means that you can change the color of the polyline
point-by-point. Try experimenting with it!</p>
<h2 id="drawing-custom-polygons"><a class="header" href="#drawing-custom-polygons">Drawing Custom Polygons</a></h2>
<p>To draw a custom filled-in polygon (and not just an outline), will we use code
very similar to our custom circle or octagon code. The main difference is that
instead of calling <code>polyline</code> to create a Builder, we call <code>polygon</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let draw: Draw = unimplemented!();
</span>let radius = 150.0;
let points = (0..=360).step_by(45).map(|i| {
    let radian = deg_to_rad(i as f32);
    let x = radian.sin() * radius;
    let y = radian.cos() * radius;
    (pt2(x,y), STEELBLUE)
});
draw.polygon()
    .points_colored(points);
<span class="boring">}</span></code></pre></pre>
<p><img src="tutorials/draw/./images/2d-custom-octogon-polygon.png" alt="An octagon" /></p>
<h2 id="concluding-remarks-1"><a class="header" href="#concluding-remarks-1">Concluding Remarks</a></h2>
<p>In this tutorial, we learned about most basic 2D drawing functions with nannou.</p>
<p>You can view the documentation for the different <code>Drawing</code> objects these return
here:</p>
<ul>
<li><a href="https://docs.rs/nannou/latest/nannou/draw/primitive/ellipse/struct.Ellipse.html">Ellipse</a></li>
<li><a href="https://docs.rs/nannou/latest/nannou/draw/primitive/rect/struct.Rect.html">Rect</a></li>
<li><a href="https://docs.rs/nannou/latest/nannou/draw/primitive/quad/struct.Quad.html">Quad</a></li>
<li><a href="https://docs.rs/nannou/latest/nannou/draw/primitive/tri/struct.Tri.html">Tri</a></li>
<li><a href="https://docs.rs/nannou/latest/nannou/draw/primitive/path/type.PathStroke.html">Polyline (or PathStroke)</a></li>
<li><a href="https://docs.rs/nannou/latest/nannou/draw/primitive/polygon/struct.Polygon.html">Polygon</a></li>
</ul>
<p>These links provide more information about other functions you can use to change
your drawings in a variety of ways.</p>
<p>You have now learned about some of the most commonly used functions for 2D
drawing with nannou. Of course, this is just scratching the surface of ways in
which you can generate shapes or polygons with nannou, but it should serve as a
solid starting point in creating your own drawings.</p>
<p>Happy coding!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animating-a-circle"><a class="header" href="#animating-a-circle">Animating a Circle</a></h1>
<p><strong>Tutorial Info</strong></p>
<ul>
<li>Author: <a href="https://madskjeldgaard.dk">madskjeldgaard</a></li>
<li>Required Knowledge:
<ul>
<li><a href="tutorials/draw//getting_started.html">Getting Started</a></li>
<li><a href="tutorials/draw//tutorials/basics/anatomy-of-a-nannou-app.html">Anatomy of a nannou app</a></li>
<li><a href="tutorials/draw//tutorials/basics/drawing-2d-shapes.html">Drawing 2D Shapes</a></li>
</ul>
</li>
<li>Reading Time: 10 minutes</li>
</ul>
<hr />
<p><img src="tutorials/draw//tutorials/basics/images/moving-circle.gif" alt="osc-circle" /></p>
<h1 id="moving-a-circle-about-on-the-screen"><a class="header" href="#moving-a-circle-about-on-the-screen">Moving a circle about on the screen</a></h1>
<p>In this tutorial we will cover the basics of moving a shape around in the window of a nannou app.</p>
<p>Let's start by making a simple program which draws a circle in the center of the screen.</p>
<p>We will be using the barebones app from <a href="tutorials/draw//tutorials/basics/anatomy-of-a-nannou-app.html">Anatomy of a nannou app</a> as a starting point for this.</p>
<p>Update the view function of your nannou-app to look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">#![allow(unused_imports)]
</span><span class="boring">extern crate nannou;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model{}
</span><span class="boring">fn main() {
</span><span class="boring">   nannou::app(model)
</span><span class="boring">       .event(event)
</span><span class="boring">       .simple_window(view)
</span><span class="boring">       .run();
</span><span class="boring">}
</span><span class="boring">fn model(_app: &amp;App) -&gt; Model {
</span><span class="boring">   Model {}
</span><span class="boring">}
</span><span class="boring">fn event(_app: &amp;App, _model: &amp;mut Model, _event: Event) {
</span><span class="boring">}
</span>fn view(app: &amp;App, _model: &amp;Model, frame: Frame) {
	// Prepare to draw.
    let draw = app.draw();

    // Clear the background to purple.
    draw.background().color(PLUM);

	// Draw a blue ellipse with a radius of 10 at the (x,y) coordinates of (0.0, 0.0)
    draw.ellipse().color(STEELBLUE).x_y(0.0,0.0);

    draw.to_frame(app, &amp;frame).unwrap();
}</code></pre></pre>
<h2 id="adding-movement"><a class="header" href="#adding-movement">Adding movement</a></h2>
<p>Let's now add some movement to our circle to give it a bit of life.</p>
<p>To do this, we will make use of the ever wonderful <a href="https://en.wikipedia.org/wiki/Sine_wave">sinewave</a>.</p>
<p>These can be generated in nannou by taking the progressed time of the application and feeding it to a sine function.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let app: App = unimplemented!();
</span>let sine = app.time.sin();
<span class="boring">}</span></code></pre></pre>
<p>Let's make another one but at half the speed by dividing the time value by two</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let app: App = unimplemented!();
</span>let slowersine = (app.time / 2.0).sin();
<span class="boring">}</span></code></pre></pre>
<p>Now that we have two functions generating nice, smooth wave movements, let's use them to control our little circle.</p>
<p>If we put these values directly in the ellipse's <code>.x_y()</code>-method we would not see much movement. That's because the sine waves generate values between -1.0 and 1.0 and the coordinates expect a pixel position.</p>
<p>But how wide is our window ? To get a precise idea of this, we can use a handy method called <a href="https://docs.rs/nannou/latest/nannou/app/struct.App.html#method.window_rect">window_rect</a> which is available in the <code>app</code> variable.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let app: App = unimplemented!();
</span>let boundary = app.window_rect();
<span class="boring">}</span></code></pre></pre>
<p>This will give us the boundary of the window as a handy <code>Rect</code>. This is a struct that responds to <a href="https://docs.rs/nannou/latest/nannou/geom/rect/struct.Rect.html">tons of useful methods</a> that we can use to define the minimum and maximum values of our x and y coordinates respectively to constrain the movements of our circle.</p>
<p>The minimum x value is thus available as:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let boundary: geom::Rect = unimplemented!();
</span>boundary.left();
<span class="boring">}</span></code></pre></pre>
<p>And the maximum x value is</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let boundary: geom::Rect = unimplemented!();
</span>boundary.right();
<span class="boring">}</span></code></pre></pre>
<p>The minimum y value is</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let boundary: geom::Rect = unimplemented!();
</span>boundary.bottom();
<span class="boring">}</span></code></pre></pre>
<p>And the maximum y value is</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let boundary: geom::Rect = unimplemented!();
</span>boundary.top();
<span class="boring">}</span></code></pre></pre>
<h2 id="mapping-values-to-a-range"><a class="header" href="#mapping-values-to-a-range">Mapping values to a range</a></h2>
<p>Using these values, we can map our <code>sine</code> and <code>slowersine</code> values to ranges of values that are within the boundary of our window. To do this, we will use the <a href="https://docs.rs/nannou/latest/nannou/math/fn.map_range.html">map_range</a> function available in nannou.</p>
<p>The <code>map_range</code> function takes 5 arguments: <code>val</code>, <code>in_min</code>, <code>in_max</code>, <code>out_min</code>, <code>out_max</code>. The <code>val</code> here is our sinewaves which has a minimum value of -1.0 and a maximum value of 1.0. For the x-coordinate, we then map it to a range of values between the leftmost point and the rightmost point.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let app: App = unimplemented!();
</span><span class="boring">    let sine = app.time.sin();
</span><span class="boring">    let boundary = app.window_rect();
</span>let x = map_range(sine, -1.0, 1.0, boundary.left(), boundary.right());
<span class="boring">}</span></code></pre></pre>
<p>And then the same for the y value but using the <code>slowersine</code> variable.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let app: App = unimplemented!();
</span><span class="boring">    let sine = app.time.sin();
</span><span class="boring">    let slowersine = (app.time / 2.0).sin();
</span><span class="boring">    let boundary = app.window_rect();
</span>let y = map_range(slowersine, -1.0, 1.0, boundary.bottom(), boundary.top());
<span class="boring">}</span></code></pre></pre>
<p>The only thing left to do now is to put this into the arguments of our circle-drawing function.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">    let app: App = unimplemented!();
</span><span class="boring">    let draw = app.draw();
</span><span class="boring">    let sine = app.time.sin();
</span><span class="boring">    let slowersine = (app.time / 2.0).sin();
</span><span class="boring">    let boundary = app.window_rect();
</span><span class="boring">    let x = map_range(sine, -1.0, 1.0, boundary.left(), boundary.right());
</span><span class="boring">    let y = map_range(slowersine, -1.0, 1.0, boundary.bottom(), boundary.top());
</span>draw.ellipse().color(STEELBLUE).x_y(x, y);
<span class="boring">}</span></code></pre></pre>
<p>Your updated <code>view</code> function should now look something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code, unreachable_code, unused_variables)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model{}
</span><span class="boring">fn main() {}
</span>fn view(app: &amp;App, _model: &amp;Model, frame: Frame) {
    // Prepare to draw.
    let draw = app.draw();

    // Generate sine wave data based on the time of the app
    let sine = app.time.sin();
    let slowersine = (app.time / 2.0).sin();

    // Get boundary of the window (to constrain the movements of our circle)
    let boundary = app.window_rect();

    // Map the sine wave functions to ranges between the boundaries of the window
    let x = map_range(sine, -1.0, 1.0, boundary.left(), boundary.right());
    let y = map_range(slowersine, -1.0, 1.0, boundary.bottom(), boundary.top());

    // Clear the background to purple.
    draw.background().color(PLUM);

    // Draw a blue ellipse at the x/y coordinates 0.0, 0.0
    draw.ellipse().color(STEELBLUE).x_y(x, y);

    draw.to_frame(app, &amp;frame).unwrap();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawing-images"><a class="header" href="#drawing-images">Drawing Images</a></h1>
<p><strong>Tutorial Info</strong></p>
<ul>
<li>Author: Josiah Savary</li>
<li>Required Knowledge:
<ul>
<li><a href="tutorials/draw//getting_started.html">Getting Started</a></li>
<li><a href="tutorials/draw/./draw-a-sketch.html">Draw a Sketch</a></li>
</ul>
</li>
<li>Reading Time: 20 minutes</li>
</ul>
<hr />
<p>In this tutorial, we explore drawing images with nannou. We will cover loading textures from images in the app's assets directory, drawing them, and applying basic transformations. You can also find this file, and other useful examples, in the <a href="https://github.com/nannou-org/nannou/tree/master/examples">examples</a> directory of the nannou source repository.</p>
<h2 id="what-is-a-texture"><a class="header" href="#what-is-a-texture">What is a Texture?</a></h2>
<p>Given the introductory nature of the tutorial, I'd like to briefly answer this question. To quote the <a href="https://sotrh.github.io/learn-wgpu">Learn Wgpu</a> website:</p>
<blockquote>
<p>Textures are images overlayed over a triangle mesh to make the mesh seem more detailed.</p>
</blockquote>
<p>In short, this is how the GPU on your machine understands how to draw images. The <a href="https://sotrh.github.io/learn-wgpu/beginner/tutorial5-textures/#loading-an-image-from-a-file">Textures and bind groups</a> is definitely worth a read for those who want to learn more.</p>
<h2 id="getting-started-2"><a class="header" href="#getting-started-2">Getting Started</a></h2>
<p>To begin, we will need to bootstrap an <code>assets</code> directory with some images at the root of our project. I recommend copying the assets directory from the <code>nannou</code> repo itself to get started. This can be accomplished from the command line like so:</p>
<pre><code class="language-bash">git clone https://github.com/nannou-org/nannou.git
cp -r nannou/assets ./assets
rm -rf nannou
</code></pre>
<p>Once you have a fleshed-out <code>assets</code> directory at the root of your project, you'll be ready to return to your <code>main.rs</code> file for the following steps.</p>
<h2 id="creating-a-window"><a class="header" href="#creating-a-window">Creating a Window</a></h2>
<p>We need somewhere to display the image, so first, let's create a window:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables, dead_code)]
</span>use nannou::prelude::*;

struct Model {}

fn main() {
  nannou::app(model).run();
}

fn model(app: &amp;App) -&gt; Model {
  // Create a new window!
  app.new_window().size(512, 512).view(view).build().unwrap();
  Model {}
}

fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
}</code></pre></pre>
<p>If you <code>cargo run</code> your app, you'll see an empty window.</p>
<h2 id="setting-up-a-texture"><a class="header" href="#setting-up-a-texture">Setting up a Texture</a></h2>
<p>Now, at the top of your <code>main.rs</code> file, add a <a href="https://docs.rs/nannou/latest/nannou/wgpu/struct.Texture.html">WGPU Texture</a> type field named <code>texture</code> to the <code>Model</code> struct.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables, dead_code)]
</span><span class="boring">use nannou::prelude::*;
</span>struct Model {
  texture: wgpu::Texture,
}
<span class="boring">fn main() {
</span><span class="boring">  nannou::app(model).run();
</span><span class="boring">}
</span><span class="boring">fn model(app: &amp;App) -&gt; Model {
</span><span class="boring">  // Create a new window!
</span><span class="boring">  app.new_window().size(512, 512).view(view).build().unwrap();
</span><span class="boring">  let texture: wgpu::Texture = unimplemented!();
</span><span class="boring">  Model { texture }
</span><span class="boring">}
</span><span class="boring">fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
</span><span class="boring">}</span></code></pre></pre>
<p>Next, we'll need to create a GPU texture to initialize the struct with. We can accomplish this by loading a texture from an image file after we create the window in our <code>model</code> function. We will let nannou find the assets directory for us using the app's <a href="https://docs.rs/nannou/0.14.1/nannou/app/struct.App.html#method.assets_path"><code>assets_path()</code></a> method, so we only need to spell out the image path from the root of that directory.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables, dead_code)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {
</span><span class="boring">  texture: wgpu::Texture,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  nannou::app(model).run();
</span><span class="boring">}
</span>fn model(app: &amp;App) -&gt; Model {
  // Create a new window!
  app.new_window().size(512, 512).view(view).build().unwrap();
  // Load the image from disk and upload it to a GPU texture.
  let assets = app.assets_path().unwrap();
  let img_path = assets.join("images").join("nature").join("nature_1.jpg");
  let texture = wgpu::Texture::from_path(app, img_path).unwrap();
  Model { texture }
}
<span class="boring">fn view(_app: &amp;App, _model: &amp;Model, _frame: Frame) {
</span><span class="boring">}</span></code></pre></pre>
<p>After all that, we've still got an empty window...but not for much longer!</p>
<h2 id="drawing-a-texture"><a class="header" href="#drawing-a-texture">Drawing a Texture</a></h2>
<p>Finally, in our <code>view</code> function, we can draw the texture stored in our model with the <code>texture</code> method of the <a href="https://docs.rs/nannou/latest/nannou/draw/struct.Draw.html">App's Draw API</a>.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables, dead_code)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {
</span><span class="boring">  texture: wgpu::Texture,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  nannou::app(model).run();
</span><span class="boring">}
</span><span class="boring">fn model(app: &amp;App) -&gt; Model {
</span><span class="boring">  // Create a new window!
</span><span class="boring">  app.new_window().size(512, 512).view(view).build().unwrap();
</span><span class="boring">  // Load the image from disk and upload it to a GPU texture.
</span><span class="boring">  let assets = app.assets_path().unwrap();
</span><span class="boring">  let img_path = assets.join("images").join("nature").join("nature_1.jpg");
</span><span class="boring">  let texture = wgpu::Texture::from_path(app, img_path).unwrap();
</span><span class="boring">  Model { texture }
</span><span class="boring">}
</span>fn view(app: &amp;App, model: &amp;Model, frame: Frame) {
  frame.clear(BLACK);

  let draw = app.draw();
  draw.texture(&amp;model.texture);

  draw.to_frame(app, &amp;frame).unwrap();
}</code></pre></pre>
<p><img src="tutorials/draw/./images/drawing-images-0.png" alt="A texture" /></p>
<h2 id="translating-and-scaling-the-texture"><a class="header" href="#translating-and-scaling-the-texture">Translating and Scaling the Texture</a></h2>
<p>A texture can be drawn at any location and any size desired within the frame. Let's say we wanted to draw this image in a 100x100 square at the top-left corner of the window. Our <code>view</code> function might look similar to the following.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables, dead_code)]
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {
</span><span class="boring">  texture: wgpu::Texture,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  nannou::app(model).run();
</span><span class="boring">}
</span><span class="boring">fn model(app: &amp;App) -&gt; Model {
</span><span class="boring">  // Create a new window!
</span><span class="boring">  app.new_window().size(512, 512).view(view).build().unwrap();
</span><span class="boring">  // Load the image from disk and upload it to a GPU texture.
</span><span class="boring">  let assets = app.assets_path().unwrap();
</span><span class="boring">  let img_path = assets.join("images").join("nature").join("nature_1.jpg");
</span><span class="boring">  let texture = wgpu::Texture::from_path(app, img_path).unwrap();
</span><span class="boring">  Model { texture }
</span><span class="boring">}
</span>fn view(app: &amp;App, model: &amp;Model, frame: Frame) {
  frame.clear(BLACK);

  let win = app.window_rect();
  let r = Rect::from_w_h(100.0, 100.0).top_left_of(win);

  let draw = app.draw();
  draw.texture(&amp;model.texture)
    .xy(r.xy())
    .wh(r.wh());

  draw.to_frame(app, &amp;frame).unwrap();
}</code></pre></pre>
<p><img src="tutorials/draw/./images/drawing-images-1.png" alt="A translated and scaled texture" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-intro-to-osc"><a class="header" href="#an-intro-to-osc">An Intro to OSC</a></h1>
<p><strong>Tutorial Info</strong></p>
<ul>
<li>Author: <a href="https://madskjeldgaard.dk">madskjeldgaard</a></li>
<li>Required Knowledge:
<ul>
<li><a href="tutorials/osc//tutorials/basics/anatomy-of-a-nannou-app.html">Anatomy of a nannou App</a></li>
</ul>
</li>
<li>Reading Time: 5 minutes</li>
</ul>
<hr />
<h2 id="what-is-osc"><a class="header" href="#what-is-osc">What is OSC?</a></h2>
<p>Open Sound Control or <a href="http://opensoundcontrol.org/">OSC</a> is a protocol for communicating between different pieces of software and/or computers. It is based on network technology and offers a flexible way to share control data between processes with a high level of precision, either internally on your local machine or through a network connection.</p>
<p>In nannou it's possible to both send and receive OSC data, allowing you to control other software or let nannou be controlled by other software.</p>
<h2 id="setting-up-osc"><a class="header" href="#setting-up-osc">Setting up OSC</a></h2>
<p>To use OSC in nannou, it is necessary to add the <code>nannou_osc</code> crate as a dependency in your nannou project.</p>
<p>Open up your <code>Cargo.toml</code> file at the root of your nannou project and add the following line under the <code>[dependencies]</code> tag:</p>
<pre><code class="language-toml">nannou_osc = "0.15.0"
</code></pre>
<p>The value in the quotes is the version of the OSC package. At the time of writing this, <code>"0.15.0"</code> is the latest version.</p>
<p>To get the latest version of the osc library, execute <code>cargo search nannou_osc</code> on the command line and read the resulting version from there.</p>
<p>To use the crate in your nannou-projects you can add a use-statement at the top of your <code>main.rs</code> file to import the OSC-functionality.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_imports)]
</span>use nannou_osc as osc;
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sending-osc"><a class="header" href="#sending-osc">Sending OSC</a></h1>
<p><strong>Tutorial Info</strong></p>
<ul>
<li>Author: <a href="https://madskjeldgaard.dk">madskjeldgaard</a></li>
<li>Required Knowledge:
<ul>
<li><a href="tutorials/osc//tutorials/basics/anatomy-of-a-nannou-app.html">Anatomy of a nannou App</a></li>
<li><a href="tutorials/osc//tutorials/basics/drawing-2d-shapes.html">Drawing 2D Shapes</a></li>
<li><a href="tutorials/osc//tutorials/tutorial/moving-a-circle-about.html">Moving a circle about on the screen</a></li>
<li><a href="tutorials/osc//tutorials/osc/osc-introduction.html">OSC introduction</a></li>
</ul>
</li>
<li>Reading Time: 20 minutes</li>
</ul>
<hr />
<p>In this tutorial we will cover how to send OSC data from a nannou app to another application using the <code>nannou_osc</code> crate.</p>
<p>We are going to write a simple program which has a circle moving about on the screen while the circle's position is sent via OSC to another application. We will continue working on the app from <a href="tutorials/osc//tutorials/basics/moving-a-circle-about.html">Moving a circle about on the screen</a>.</p>
<h2 id="setting-up-an-osc-sender"><a class="header" href="#setting-up-an-osc-sender">Setting up an OSC sender</a></h2>
<p>At the top of your <code>main.rs</code>-file, import the <code>nannou_osc</code> crate and make it available in your program via the shorthand <code>osc</code>.</p>
<pre><pre class="playground"><code class="language-rust  norun"><span class="boring">#![allow(unused_imports)]
</span>use nannou_osc as osc;
<span class="boring">fn main(){}</span></code></pre></pre>
<p>The first thing we then need to do is set up our OSC-sender in the <code>Model</code>-struct you may have seen in other nannou-tutorials.
Add a field to the struct called <code>sender</code> with a <a href="https://docs.rs/nannou_osc/latest/nannou_osc/send/struct.Sender.html">Sender</a>-struct as the type input.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code, unused_imports)]
</span><span class="boring">use nannou_osc as osc;
</span>struct Model {
    sender: osc::Sender&lt;osc::Connected&gt;,
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Next, we need to setup our <code>Model</code> struct using the <code>model</code> function. Don't worry if it looks a bit daunting at first, we will go through it step by step.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(dead_code, unused_imports)]
</span><span class="boring">use nannou_osc as osc;
</span><span class="boring">use nannou::prelude::*;
</span><span class="boring">struct Model {
</span><span class="boring">  sender: osc::Sender&lt;osc::Connected&gt;,
</span><span class="boring">}
</span>fn model(_app: &amp;App) -&gt; Model {
    let port = 1234;
    let target_addr = format!("{}:{}", "127.0.0.1", port);

	let sender = osc::sender()
        .expect("Could not bind to default socket")
        .connect(target_addr)
        .expect("Could not connect to socket at address");

    Model { sender }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>First, let's choose the network port that our data will be sent to.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let port = 1234;
<span class="boring">}</span></code></pre></pre>
<p>The osc-sender expects a string in the format "address:port", for example <code>"127.0.0.1:1234"</code>.</p>
<p>The address can either be an internal address or the address of another computer on your network. In this tutorial we will be targetting our own computer's internal address which is represented by <code>"127.0.0.1"</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let port = 1234;
</span>let target_addr = format!("{}:{}", "127.0.0.1", port);
<span class="boring">}</span></code></pre></pre>
<p>Lastly, we need to bind our OSC sender to the network socket. This isn't always successful, so we are attaching the <code>expect()</code>-method (read more about <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>expect()</code> here</a>) to post an error message if it is not successful. If it is successful, the <code>.connect(target_addr)</code>-method is used to connect the sender to the target address. Again, this may be unsuccesful so we use the <code>expect()</code>-method on the result of that operation as well.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">use nannou_osc as osc;
</span><span class="boring">fn main() {
</span><span class="boring">    let port = 1234;
</span><span class="boring">    let target_addr = format!("{}:{}", "127.0.0.1", port);
</span>let sender = osc::sender()
    .expect("Could not bind to default socket")
    .connect(target_addr)
    .expect("Could not connect to socket at address");
<span class="boring">}</span></code></pre></pre>
<h3 id="sending-osc-messages"><a class="header" href="#sending-osc-messages">Sending OSC messages</a></h3>
<p>An OSC packet consists of at least two components: An OSC address and 0 or more arguments containing data. The OSC address is not to be confused with the network address we connected to before. Instead, an OSC address is a path sort of like a URL, for example <code>/circle/position</code>.</p>
<p>To create an OSC packet, we first need to make an address.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let osc_addr = "/circle/position".to_string();
<span class="boring">}</span></code></pre></pre>
<p>Then create a vector of arguments. These need to be formatted using the types found in <a href="https://docs.rs/nannou_osc/latest/nannou_osc/enum.Type.html">osc::Type</a> in the nannou_osc crate. Below we create an argument list of two floating point values: the <code>x</code> and <code>y</code> coordinates of our circle.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">use nannou_osc as osc;
</span><span class="boring">fn main() {
</span><span class="boring">let x = 0.0;
</span><span class="boring">let y = 0.0;
</span>let args = vec![osc::Type::Float(x), osc::Type::Float(y)];
<span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<p>Now, bringing these two things together we get an OSC packet. The sender expect these to be delivered in a tuple.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let osc_addr = unimplemented!();
</span><span class="boring">let args = unimplemented!();
</span>let packet = (osc_addr, args);
<span class="boring">}</span></code></pre></pre>
<p><a href="https://docs.rs/nannou_osc/latest/nannou_osc/send/struct.Sender.html#method.send-1">Reading the documentation</a> for the <code>send</code>-method, we can see that it returns a Result type which will either contain the number of bytes written (if it was successful) and, more importantly, some useful errors of type CommunicationError if it was not succesful. To discard the error part of this, we use the <code>ok()</code> method at the end.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unreachable_code, unused_variables)]
</span><span class="boring">use nannou_osc as osc;
</span><span class="boring">struct Model {
</span><span class="boring">   sender: osc::Sender&lt;osc::Connected&gt;,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">   let model: Model = unimplemented!();
</span><span class="boring">   let osc_addr = "/circle/position".to_string();
</span><span class="boring">   let args = vec![osc::Type::Float(0.0), osc::Type::Float(0.0)];
</span><span class="boring">   let packet = (osc_addr, args);
</span>    model.sender.send(packet).ok();
<span class="boring">}</span></code></pre></pre>
<h2 id="the-finished-app"><a class="header" href="#the-finished-app">The finished app</a></h2>
<pre><pre class="playground"><code class="language-rust no_run">use nannou::prelude::*;
use nannou_osc as osc;

fn main() {
    nannou::app(model).simple_window(view).run();
}

struct Model {
    sender: osc::Sender&lt;osc::Connected&gt;,
}

fn model(_app: &amp;App) -&gt; Model {
    // The network port that data is being sent to
    let port = 1234;

    // The osc-sender expects a string in the format "address:port", for example "127.0.0.1:1234"
    // "127.0.0.1" is equivalent to your computers internal address.
    let target_addr = format!("{}:{}", "127.0.0.1", port);

    // This is the osc Sender which contains a couple of expectations in case something goes wrong.
    let sender = osc::sender()
        .expect("Could not bind to default socket")
        .connect(target_addr)
        .expect("Could not connect to socket at address");

    Model { sender }
}

fn view(app: &amp;App, model: &amp;Model, frame: Frame) {
    // Use app time to progress through a sine wave
    let sine = app.time.sin();
    let slowersine = (app.time / 2.0).sin();

    // Get boundary of the window (to constrain the movements of our circle)
    let boundary = app.window_rect();

    // Map the sine wave functions to ranges between the boundaries of the window
    let x = map_range(sine, -1.0, 1.0, boundary.left(), boundary.right());
    let y = map_range(slowersine, -1.0, 1.0, boundary.bottom(), boundary.top());

    // Send x-y coordinates as OSC
    let osc_addr = "/circle/position".to_string();
    let args = vec![osc::Type::Float(x), osc::Type::Float(y)];
    let packet = (osc_addr, args);

    model.sender.send(packet).ok();

    // Prepare to draw.
    let draw = app.draw();

    // Clear the background to purple.
    draw.background().color(PLUM);

    // Draw a blue ellipse at the x/y coordinates 0.0, 0.0
    draw.ellipse().color(STEELBLUE).x_y(x, y);

    draw.to_frame(app, &amp;frame).unwrap();
}</code></pre></pre>
<p>In the next tutorial we will take a look at how to receive our OSC values and do something interesting with them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="community-tutorials"><a class="header" href="#community-tutorials">Community Tutorials</a></h1>
<p>This is a collection of tutorials by the community.</p>
<ul>
<li>
<p><strong><a href="https://github.com/sidwellr/schotter">"Schotter Four Ways"</a>.</strong>	A comprehensive generative art tutorial by Rick Sidwell introducing Rust workspaces, sketches vs. apps, multiple windows, image capture, keyboard input, and user interfaces.</p>
</li>
<li>
<p><strong><a href="https://dev.to/deciduously/creative-coding-in-rust-with-nannou-1lbl">"Creative Coding in Rust with Nannou"</a>.</strong> A Rust/Nannou tutorial by Ben Lovy detailing an idiomatic Rust approach to creative coding. It sets up a general framework that is useful for general projects, then uses it to code a simple demo application.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Considering contributing to nannou? Awesome! Hopefully this section can guide
you in the right direction.</p>
<ul>
<li><a href="./contributing/about-the-codebase.html"><strong>About the Codebase</strong></a></li>
<li><a href="./contributing/pr-checklist.html"><strong>PR Checklist</strong></a></li>
<li><a href="./contributing/pr-reviews.html"><strong>PR Reviews</strong></a></li>
<li><a href="./contributing/publishing-new-versions.html"><strong>Publishing New Versions</strong></a></li>
</ul>
<h2 id="still-have-questions"><a class="header" href="#still-have-questions">Still have questions?</a></h2>
<p>Remember, if you are still unsure about anything, you probably are not the only
one! Feel free to <a href="https://github.com/nannou-org/nannou/issues">open an issue</a> with your question.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-the-codebase"><a class="header" href="#about-the-codebase">About the Codebase</a></h1>
<p>The nannou community uses <a href="https://en.wikipedia.org/wiki/Git">git</a> for managing and collaborating on all code
and documentation, including this guide! At the moment, the main code repository
(repo) is hosted <a href="https://github.com/nannou-org/nannou">at Github</a>.</p>
<h3 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h3>
<p>All code changes and code reviews for nannou happen through "Pull Requests"
(PRs). If you are new to pull requests, there are <a href="https://duckduckgo.com/?t=ffab&amp;q=how+to+make+a+pul+request+github&amp;ia=web">many great guides out
there</a>, but in short they are a nice way of proposing, reviewing,
discussing and merging changes to a codebase.</p>
<p>In the next section we'll take a look at a checklist for opening PRs at the
nannou repo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pr-checklist"><a class="header" href="#pr-checklist">PR Checklist</a></h1>
<p>When creating a PR, there are a few things you can do to help the process of
landing your changes go smoothly:</p>
<ul>
<li><strong>Code Formatting</strong> - The most common step to forget is running <code>cargo fmt --all</code> (I forget all the time)! This step ensures there is a consistent style
across nannou's codebase.</li>
<li><strong>Errors</strong> - All changes must build successfully, and all tests must complete
successfully before we can merge each PR. Keep in mind that running tests
locally can take a loooooong time, so sometimes it can be easier to open your
PR and let the repo bot check for you.</li>
<li><strong>Warnings</strong> - Make sure to address any lingering code warnings before your
last commit. Keep in mind that sometimes warnings already exist due to changes
in the compiler's linter between versions. Try to at least make sure that your
changes do not add any new ones :)</li>
<li><strong>Check Examples</strong> - Make sure the examples still work by running
<code>cargo run --bin run_all_examples</code>. This executes a script that builds and runs
all the examples in the project. You need to do a manual check to see
if examples have failed to run successfully (e.g. check for wgpu validation errors).</li>
<li><strong>Documentation</strong> - If you have made any changes that could benefit from
updating some code documentation, please be sure to do so! Try to put yourself
in the shoes of someone reading your code for the first time.</li>
<li><strong>Changelog</strong> - <a href="https://guide.nannou.cc/changelog.html">The changelog</a> acts as a human-friendly
history of the repo that becomes especially useful to community members when
updating between different versions of nannou. Be sure to add your changes to
<code>guide/src/changelog.md</code>.</li>
<li><strong>PR Comment</strong> - Be sure to add the following to your PR to make it easier for
reviewers to understand and land your code:
<ul>
<li><strong>Motivation</strong> for changes. What inspired the PR? Please link to any
related issues.</li>
<li><strong>Summary</strong> of changes. Anything that might help the reviewer to
understand your what your changes do will go a long way!</li>
</ul>
</li>
</ul>
<p>If you forget one of these steps before making your PR, don't panic! The nannou
repo has a CI (continuous integration) bot that will check for some of these
steps and notify you if anything is out of order. Once the bot checks pass, a
community member will review the rest.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pr-reviews"><a class="header" href="#pr-reviews">PR Reviews</a></h1>
<p>Now that you have made your PR it is time to wait for a review.</p>
<p>Keep in mind that for the most part, the nannou team and community members take
care of nannou in their personal time. As a result, it's difficult to say how
long it will take before your code is reviewed and accepted.</p>
<p>Here are some things you can do to help land your PR quickly:</p>
<ul>
<li><strong>Follow the <a href="contributing/./pr-checklist.html">PR Checklist</a></strong>.</li>
<li><strong>Request a review</strong> from another community member. In particular, if your PR
addresses an issue that someone else has commented on, they might be
interested in taking a look. Reviews from other community members will make it
much easier for the maintainers to trust and land your changes. Knowing this,
if you see a PR from another community member, you might consider offering
your own review!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-new-versions"><a class="header" href="#publishing-new-versions">Publishing New Versions</a></h1>
<p>The nannou repo allows community members to open a PR for publishing a new
version of any or all of the nannou crates. This makes it much easier for
maintainers to publish a new release - all we have to do is accept your PR!</p>
<p>If you would like to see a new version of a crate published, follow these steps:</p>
<h2 id="choose-a-version"><a class="header" href="#choose-a-version">Choose a Version</a></h2>
<p>The version to use for the next version of the crate(s) you wish to publish will
depend on the changes that have been made to the crate(s). The nannou crates
follow the rust convention which you can read about <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-version-field">here</a>.</p>
<blockquote>
<p><em><strong>Hot tip</strong>! Each of the numbers in a crate version has its own name:</em></p>
<pre><code>MAJOR.MINOR.PATCH
</code></pre>
<p><em>E.g. in the version <code>0.15.3</code> the <code>0</code> is the "major" version, the <code>15</code> is the
"minor" version and the <code>3</code> is the "patch" or "tiny" version. Keep an eye out
for these names when reading about versioning in Rust.</em></p>
</blockquote>
<p>Also necessary to keep in mind is that nannou synchronises versions that
represent a breaking change (e.g. a change from <code>0.15.3</code> to <code>0.16.0</code> or <code>1.0.4</code>
to <code>2.0.0</code>). In these cases, all crates with the name <code>nannou</code> or <code>nannou_*</code>
should be published together with the same version. This version synchronisation
makes it easier for users to intuit compatible versions of nannou crates without
the need to manually check all of the dependency versions on crates.io.</p>
<h2 id="update-cargotoml"><a class="header" href="#update-cargotoml">Update Cargo.toml</a></h2>
<p>There are two sections of the <code>Cargo.toml</code> file(s) that will need updating.</p>
<ol>
<li>The <code>version</code> field under the <code>[package]</code> section.</li>
<li>The <code>version</code> field of the <code>[dependencies]</code> and <code>[dev-dependencies]</code>
sections of each crate in the repo that uses the crate. E.g. the <code>nannou</code>
crate is a dependency of <code>nannou_isf</code>. If we wish to update the version of
<code>nannou</code>, we will also need to update the version of <code>nannou</code> specified in
the <code>[dependencies]</code> section of <code>nannou_isf</code>.</li>
</ol>
<p>This can be quite a lot of Cargo.toml changes in the case that you are updating
the version of all of the <code>nannou_*</code> crates!</p>
<p>To make this easier, the nannou repo includes a small program at
<code>scripts/set_version</code>. You can use it like so:</p>
<pre><code>cargo run --bin set_version -- "0.42.0"
</code></pre>
<p>This will:</p>
<ul>
<li>Find all crates via the cargo workspace Cargo.toml file.</li>
<li>Sets the specified version number for each of the <code>nannou*</code> packages and
updates each of their respective <code>nannou*</code> dependencies.</li>
<li>Edits their Cargo.toml files with the result.</li>
</ul>
<h2 id="update-the-guide"><a class="header" href="#update-the-guide">Update the Guide</a></h2>
<p>There are two places where we must update the version in the guide:</p>
<ol>
<li>The <strong>Changelog</strong>. You can find it at <code>guide/src/changelog.md</code>. See the most
recent version in the guide for a demonstration of how to update the version.
For the most part, this just involves adding a date and release heading under
the <code>Unreleased</code> heading.</li>
<li>Update the nannou version number in step 3 of the
<code>guide/src/getting_started/create_a_project.md</code> section.  See the
<code>[dependencies]</code> section of the code snippet.</li>
</ol>
<p>Otherwise, we avoid referring to specific versions in the guide to make updating
easier. If you happen to be familiar with grep, this command can help you to
double check that there are no more places to update:</p>
<pre><code>grep -nr "= \"0.14\"" guide/
</code></pre>
<p>where <code>0.14</code> would be replaced with the beginning of the previous version of
<code>nannou</code>. This should should list the files and line numbers where the previous
version still exists and likely needs updating.</p>
<h2 id="open-a-pr"><a class="header" href="#open-a-pr">Open a PR</a></h2>
<p>Now you should be ready to open a PR! Be sure to follow the <a href="contributing/./pr-checklist.html">PR
Checklist</a>.</p>
<p>Once your PR is reviewed and merged, the nannou repo's CI bot will automatically
publish the new versions.</p>
<p>Congrats, you just published some new goodies to crates.io for the nannou
community!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developer-reference-1"><a class="header" href="#developer-reference-1">Developer Reference</a></h1>
<p><strong>TODO:</strong> A guide to the architecture of Nannou's internals to help onboard new
developers. Describes the layout of modules, how to navigate the reference, the
scope of the main nannou crate i.e. the kinds of work that should go inside the
main repo and the kinds that might be better off in separate repos, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-1"><a class="header" href="#api-reference-1">API Reference</a></h1>
<p>Eventually, we would like to host the API documentation here. For now, you can
find it at <a href="https://docs.rs/nannou">docs.rs/nannou</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="showcases-1"><a class="header" href="#showcases-1">Showcases</a></h1>
<p><strong>TODO:</strong> A collection of work made with nannou, perhaps ordered from most
recent to the past. Users could do a PR to have their own nannou projects
published.</p>
<ul>
<li><a href="https://github.com/mitchmindtree/nannou-sketches">sketches by mitchmindtree</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>All notable changes to nannou should be documented below! From the most recent,
back to the origins.</p>
<hr />
<h1 id="unreleased"><a class="header" href="#unreleased">Unreleased</a></h1>
<p><em>There are currently no unreleased changes.</em></p>
<hr />
<h1 id="version-0190-2024-01-17"><a class="header" href="#version-0190-2024-01-17">Version 0.19.0 (2024-01-17)</a></h1>
<ul>
<li>Add GL backend to default backends for better WASM support.</li>
<li>Add CI for testing the <code>wasm32-unknown-unknown</code> target.</li>
<li>Enable <code>wgpu/webgl</code> when <code>wasm</code> feature is enabled.</li>
<li>Merge the <code>nannou_egui</code> repo into the main <code>nannou</code> repo.</li>
<li>Move <code>nannou_conrod</code> and <code>nannou_timeline</code> into a new repository:
https://github.com/nannou-org/nannou_conrod. Both crates are deprecated in
favour of <code>nannou_egui</code>.</li>
<li>Switch from <code>async-std</code> to <code>tokio</code> for async texture capture handling.</li>
<li>Switch <code>egui_wgpu_backend</code> to the in-tree <code>egui-wgpu</code>.</li>
<li>Update <code>egui</code> to <code>0.23</code>.</li>
<li>Update <code>wgpu</code> to <code>0.17</code>.</li>
<li>Update <code>winit</code> to <code>0.28</code>. (See #940).</li>
</ul>
<p><em><strong>Note: version 0.19 will be the last stable version prior to the bevy-plugin
refactor/overhaul. See https://github.com/nannou-org/nannou/issues/946 for
details on the planned changes, and refer to the <code>bevy-refactor</code> branch for
progress once it's available.</strong></em></p>
<hr />
<h1 id="nannou-0181-2021-12-17"><a class="header" href="#nannou-0181-2021-12-17"><code>nannou</code> 0.18.1 (2021-12-17)</a></h1>
<ul>
<li>Expose missing <code>begin()</code> method in <code>geom::path::Builder</code>.</li>
<li>Set window class for X11 running apps.</li>
<li>Ensure wakeup calls (<code>UserEvent</code>s) provide updates in <code>Wait</code> mode.</li>
</ul>
<hr />
<h1 id="version-0180-2021-11-15"><a class="header" href="#version-0180-2021-11-15">Version 0.18.0 (2021-11-15)</a></h1>
<h3 id="wgpu-09---011"><a class="header" href="#wgpu-09---011">wgpu 0.9 -&gt; 0.11</a></h3>
<p><strong>Note:</strong> As of wgpu 0.10, all nannou projects now require either:</p>
<ol>
<li>The following line in their top-level cargo manifest:
<pre><code class="language-toml">resolver = "2"
</code></pre>
OR</li>
<li>All packages must use the 2021 edition (or later) of Rust, e.g.
<pre><code class="language-toml">edition = "2021"
</code></pre>
</li>
</ol>
<p>This requirement is due to wgpu 0.10's reliance on the new version of cargo's
dependency resolver and how it unifies features. Without either of the above
amendments, you will likely run into strange upstream compilation errors. You
can read more about the cargo dependency resolver versions here:</p>
<p>https://doc.rust-lang.org/cargo/reference/resolver.html#resolver-versions</p>
<ul>
<li>As of wgpu 0.10, it is now pure Rust! No more SPIR-V cross.</li>
<li>The concept of the wgpu <code>SwapChain</code> has been removed by merging it into the
<code>Surface</code>, simplifying internals and improving approachability.</li>
<li>WGSL is now wgpu's default shader format. All internal shaders and examples
have been updated to use WGSL instead of SPIR-V.</li>
<li>A new <code>spirv</code> feature has been added that enables the old behaviour of
accepting SPIR-V. This is disabled by default to try and keep build times low.</li>
<li><code>TextureUsage</code>, <code>BufferUsage</code>, <code>ColorWrite</code> are renamed to plural.</li>
<li>Renamed <code>TextureUsage</code> consts: <code>SAMPLED</code> -&gt; <code>TEXTURE_BINDING</code>, <code>STORAGE</code> -&gt;
<code>STORAGE_BINDING</code>.</li>
<li>Renamed <code>InputStepMode</code> to <code>VertexStepMode</code>.</li>
<li>Readable storage textures are no longer a part of the base API. They are now
exposed via format-specific features, non-portably.</li>
<li>Added limits for binding sizes, vertex data, per-stage bindings, and others.</li>
<li>Adds ability to request a software (fallback) adapter.</li>
</ul>
<p>For more details, see the wgpu CHANGELOG:</p>
<ul>
<li>0.10: https://github.com/gfx-rs/wgpu/blob/master/CHANGELOG.md#v010-2021-08-18</li>
<li>0.11: https://github.com/gfx-rs/wgpu/blob/master/CHANGELOG.md#wgpu-011-2021-10-07</li>
</ul>
<h3 id="general"><a class="header" href="#general">General</a></h3>
<ul>
<li>Update <code>lyon</code> to version <code>0.17</code>.</li>
<li>Refactor the <code>nannou::mesh</code> module into a <code>nannou_mesh</code> crate, re-exported to
maintain the same API.</li>
<li>Refactor the <code>nannou::wgpu</code> module into a <code>nannou_wgpu</code> crate, re-exported to
maintain the same API.</li>
<li>Remove the <code>nannou::ui</code> module in favour of providing a <code>nannou_conrod</code> crate.
See the updated <code>examples/ui/conrod</code> examples to find out how to update. Note
that input must now be manually submitted to the <code>Ui</code> and is no longer done
automatically by the nannou <code>App</code>. The easiest approach is to register a
<code>raw_event</code> function with the <code>Ui</code>'s window. Refer to the updated examples for
demonstration.</li>
<li>Add community tutorials section to the guide.</li>
<li>Provided an user-friendly way to get the character value of a pressed keyboard key.</li>
<li>Clear surface background automatically when re-allocated. Can set the clear
color via <code>WindowBuilder::clear_color()</code>.</li>
<li>Provided a method which allows users to specify an initial default <code>LoopMode</code>
in both <code>SketchBuilder</code> and <code>Builder</code>. Updated the relevant example to
showcase the new functionality.</li>
<li>Remove unused <code>daggy</code> dependency.</li>
<li>Avoids calling <code>update</code> under <code>LoopMode::Wait</code> if no events were received.</li>
</ul>
<hr />
<h3 id="nannou-0171-2021-07-02"><a class="header" href="#nannou-0171-2021-07-02"><code>nannou</code> 0.17.1 (2021-07-02)</a></h3>
<ul>
<li>Fix some edge-cases in the behaviour of <code>io::safe_file_save</code>.</li>
</ul>
<hr />
<h1 id="version-0170-2021-06-20"><a class="header" href="#version-0170-2021-06-20">Version 0.17.0 (2021-06-20)</a></h1>
<p><strong>Upgrade WGPU to 0.9</strong></p>
<p>Most changes have been about renaming Blend-related data structres and fixing shaders to avoid sampling textures inside of conditionals (wgpu validation layer found this one).</p>
<ul>
<li>Item Name changes:
<ul>
<li><code>BlendState</code> -&gt; <code>BlendComponent</code></li>
<li><code>wgpu::Extend3d::depth</code> -&gt; <code>wgpu::Extend3d::depth_of_array_layers</code></li>
<li>Float tpes are now typed more descripively. E.g., <code>Float2</code> -&gt; <code>Float32x2</code></li>
</ul>
</li>
</ul>
<p><strong>Refactor core of <code>nannou</code> into <code>nannou_core</code> crate</strong></p>
<ul>
<li>Add a new <code>nannou_core</code> crate, targeted towards headless or embedded apps,
libraries and rust-gpu.</li>
<li>Move the <code>color</code>, <code>geom</code>, <code>math</code> and <code>rand</code> crates into <code>nannou_core</code>.</li>
<li>Remove the <code>geom::Graph</code> type due to lack of strong use-case and no reports of
use.</li>
<li>Remove generic scalar param from <code>Draw</code> API in favour of using <code>f32</code>
generally.</li>
<li>Remove <code>cgmath</code> computer graphics linear algebra lib in favour of <code>glam</code> for
faster compile times, simpler API, easier documentation, <code>no_std</code> support and
more.</li>
<li>Refactor the <code>Rect</code> and <code>Cuboid</code> method implementations that expose <code>Point</code>
and <code>Vec</code> to avoid breakage. Previously, our <code>Point</code> and <code>Vector</code> types were
generic, however as of switching to <code>glam</code> this is no longer the case.
Instead, methods that used these types are now implemented independently for
<code>Rect&lt;f32&gt;</code> and <code>Rect&lt;f64&gt;</code> (likewise for <code>Cuboid</code>).</li>
</ul>
<p><strong>General</strong></p>
<ul>
<li>Fix a bug in <code>text::line::Infos</code> iterator where reported character index was
incorrect.</li>
<li>Fix <code>glyph_colors</code> miscoloring on resize.</li>
<li>Enable serializing of color types.</li>
<li>Enable <code>nannou_laser</code> features for documentation build.</li>
<li>Update dependencies:
<ul>
<li><code>conrod_*</code> from 0.73 to 0.74.</li>
<li><code>noise</code> from 0.6 to 0.7 (<code>image</code> feature no longer enabled).</li>
<li><code>rand</code> from 0.7 to 0.8 (changes <code>gen_range(a,b)</code> to <code>gen_range(a..b)</code>)</li>
</ul>
</li>
</ul>
<hr />
<h1 id="version-0160-2021-04-21"><a class="header" href="#version-0160-2021-04-21">Version 0.16.0 (2021-04-21)</a></h1>
<ul>
<li>Add ability to color characters individually to <code>Draw</code> API, i.e.
<code>draw.text().glyph_colors(color_iter)</code>.</li>
<li>Add a <code>app.quit()</code> method to allow for quitting the application without user
input.</li>
<li>Use the <code>instant</code> crate rather than <code>std::time::Instant</code> in preparation for
wasm support.</li>
<li>Fix a major memory leak and various resize crashes - thanks danwilhelm!</li>
<li>Fix non-uniform scaling in <code>Draw</code> API.</li>
</ul>
<p><strong>Update to wgpu 0.7</strong></p>
<p>These changes mostly involved renaming of items, though also included some
significant refactoring of the <code>wgpu::RenderPipeline</code>.</p>
<ul>
<li>The <code>wgpu::RenderPipelineBuilder</code> had some methods added, some removed in
order to more closely match the newly refactored <code>wpgu::RenderPipeline</code>.
Documentation of <code>RenderPipelineBuilder</code> methods has been added to match
the upstream wgpu docs of the associated fields.</li>
<li>The <code>Sampler</code> binding type now requires specifying whether or not it uses the
<code>Linear</code> option for any of its minify, magnify or mipmap filters. A
<code>wgpu::sampler_filtering</code> function was added to make it easier to retrieve
this bool from the <code>SamplerDescriptor</code>.</li>
<li>The vertex buffer <code>IndexFormat</code> is now specified while setting the index
buffer in the render pass command, rather than in the render pipeline
descriptor.</li>
<li>Item name changes include:
<ul>
<li><code>PowerPreference::Default</code> -&gt; <code>PowerPreference::LowPower</code></li>
<li><code>TextureUsage::OUTPUT_ATTACHMENT</code> -&gt; <code>TextureUsage::RENDER_ATTACHMENT</code></li>
<li><code>TextureComponentType</code> -&gt; <code>TextureSampleType</code></li>
<li><code>component_type</code> -&gt; <code>sample_type</code> (for textures)</li>
<li><code>BlendDescriptor</code> -&gt; <code>BlendState</code></li>
<li><code>VertexAttributeDescriptor</code> -&gt; <code>VertexAttribute</code></li>
<li><code>BindingType::SampledTexture</code> -&gt; <code>BindingType::Texture</code></li>
<li><code>ColorStateDescriptor</code> -&gt; <code>ColorTargetState</code></li>
<li><code>DepthStencilStateDescriptor</code> -&gt; <code>DepthStencilState</code></li>
<li><code>VertexBufferDescriptor</code> -&gt; <code>VertexBufferLayout</code></li>
</ul>
</li>
<li>Also updates related dependencies:
<ul>
<li><code>conrod_derive</code> and <code>conrod_core</code> to <code>0.72</code>.</li>
</ul>
</li>
</ul>
<p><strong>Update to wgpu 0.6</strong></p>
<p>For the most part, these changes will affect users of the <code>nannou::wgpu</code> module,
but not so much the users of the <code>draw</code> or <code>ui</code> APIs. <em>Find the relevant wgpu
changelog entry
<a href="https://github.com/gfx-rs/wgpu/blob/master/CHANGELOG.md#v06-2020-08-17">here</a>.</em></p>
<ul>
<li><code>Window::current_monitor</code> now returns a result.</li>
<li><code>wgpu::Device::create_buffer_with_data</code> has been removed in favour of
a new <code>wgpu::DeviceExt::create_buffer_init</code> trait method that takes a
<code>wgpu::BufferInitDescripor</code> as an argument.</li>
<li><code>wgpu::BufferDescriptor</code> now requires specifying whether or not the buffer
should be mapped (accessible via CPU) upon creation.</li>
<li>The swap chain queue <code>submit</code> method now takes an iterator yielding commands
rather than a slice.</li>
<li>The async API for mapped reads/writes has changed.</li>
<li><code>wgpu::Buffer</code>s can now be sliced.</li>
<li><code>wgpu::PipelineLayoutDescriptor</code> requires specifying <code>push_constant_ranges</code>.</li>
<li>The render pass <code>set_vertex_buffer</code> method now takes a buffer slice directly,
rather than a range.</li>
<li>A new <code>wgpu::TextureViewInfo</code> type was added. It represents the
<code>wgpu::TextureViewDescriptor</code> parameters that were supplied to build a
<code>wgpu::TextureView</code>.</li>
<li>A top-level <code>wgpu::Instance</code> type has been introduced.</li>
<li>Load and store ops have been consolidated into a <code>wgpu::Operations</code> type.</li>
<li><code>wgpu::Binding</code> was renamed to <code>wgpu::BindGroupEntry</code>.</li>
<li>A <code>RowPaddedBuffer</code> abstraction was added to more gracefully/safely handle
conversions between <code>wgpu::Buffer</code>s and <code>wgpu::Texture</code>s.</li>
<li>Updates some dependencies:
<ul>
<li><code>audrey</code> to 0.3.</li>
<li><code>winit</code> to 0.24.</li>
<li><code>conrod_derive</code> and <code>conrod_core</code> to 0.71 (<code>nannou_timeline</code> only).</li>
</ul>
</li>
</ul>
<h3 id="nannou_audio"><a class="header" href="#nannou_audio">nannou_audio</a></h3>
<ul>
<li>Update to CPAL 0.13.1 and from <code>sample</code> to <code>dasp_sample</code>.</li>
<li>Add the ability to specify a device buffer size.</li>
<li>Allow fallback to device default sample rate.</li>
<li>Add builder method for specifying a stream error callback. This replaces the
<code>render_result/capture_result</code> functions.</li>
<li>Switch from <code>failure</code> to <code>thiserror</code> for error handling.</li>
<li>Rename <code>format</code> to <code>config</code> throughout to match cpal 0.12.</li>
<li>Fix bug where stream channel count could be greater than specified.</li>
</ul>
<hr />
<h1 id="version-0150-2020-10-04"><a class="header" href="#version-0150-2020-10-04">Version 0.15.0 (2020-10-04)</a></h1>
<p><strong>Update to WGPU 0.5</strong></p>
<p>For the most part, these changes will affect users of the <code>nannou::wgpu</code> module,
but not so much the users of the <code>draw</code> or <code>ui</code> APIs. <em>Find the relevant wgpu
changelog entry
<a href="https://github.com/gfx-rs/wgpu/blob/master/CHANGELOG.md#v05-06-04-2020">here</a>.</em></p>
<ul>
<li>The <em>y</em> axis has been inverted for wgpu pipelines, meaning the y axis now
increases upwards in NDC (normalised device coordinates). This does not affect
the <code>Draw</code> or <code>Ui</code> APIs, but does affect users creating custom render
pipelines. The updated wgpu examples should demonstrate how to deal with this
change.</li>
<li><code>wgpu::Device</code> no longer offers a generic buffer creation method, instead
requiring that users upload all data as slices of bytes. This required adding
some small <code>unsafe</code> functions for converting data (most often vertices,
indices and uniforms) to bytes ready for upload to the GPU. See the new
<code>wgpu::bytes</code> module docs for details.</li>
<li><code>wgpu::VertexDescriptor</code> trait has been removed in favour of a new
<code>wgpu::vertex_attr_array!</code> macro. See updated wgpu examples for a usage
demonstration.</li>
<li><code>wgpu::BindGroupLayout</code> now requires the texture component type for sampled
texture binding types. This means wgpu users may now need to switch between
render pipelines if dynamically switching between textures at runtime.</li>
<li><code>wgpu::Texture</code> and <code>wgpu::TextureView</code> now expose a <code>component_type</code> method,
allowing for easy retrieval of the <code>wgpu::TextureComponentType</code> associated
with their <code>wgpu::TextureFormat</code>.</li>
<li>Fixes a bug where sometimes <code>Draw</code> items could be drawn with an incorrect
blend mode, primitive topology or bind group.</li>
<li><code>wgpu::Queue</code>s no longer requires mutable access when submitting command
buffers. This allowed for the removal of the awkward <code>Mutex</code> that was exposed
when providing access to the window's swapchain queue.</li>
<li>The <code>Frame::TEXTURE_FORMAT</code> has changed from <code>Rgba16Unorm</code> to <code>Rgba16Float</code>,
as the <code>Rgba16Unorm</code> format was removed from the WGPU spec due to lack of
consistent cross-platform support. Similarly, <code>image::ColorType</code>'s that were
previously mapped to <code>Unorm</code> formats are now mapped their respective <code>Uint</code>
formats instead.</li>
<li>Update to conrod 0.70 to match wgpu dependency version.</li>
<li>Remove <code>threadpool</code> crate in favour of <code>futures</code> crate thread pool feature.
This is necessary in order to run <code>TextureCapturer</code> futures now that they take
advantage of rust's async futures API.</li>
<li>Adds the <code>num_cpus</code> dependency for selecting a default number of worker
threads for the <code>TextureCapturer</code>'s inner thread pool.</li>
</ul>
<p><strong>Texture Capturing Fixes and Improvements</strong></p>
<ul>
<li>Fixes the issue where <code>TextureCapturer</code> could spawn more user callbacks than
there where worker threads to process them.</li>
<li>Fixes the issue where an application might exit before all
<code>window.capture_frames(path)</code> snapshots have completed.</li>
<li>Provides a <code>TextureCapturer::await_active_snapshots(device)</code> method that
allows to properly await the completion of all snapshot read futures by
polling the device as necessary.</li>
<li><code>TextureCapturer::new</code> now takes the number of workers and optional timeout
duration as an argument.</li>
<li><code>Snapshot::read_threaded</code> has been removed in favour of a single
<code>Snapshot::read</code> method that is threaded by default. The old synchronous
behaviour can be emulated by creating the <code>TextureCapturer</code> with a single
worker. Likewise, <code>window.capture_frame_threaded</code> has been removed in favour
of <code>window.capture_frame</code> for the same reason.</li>
<li>New <code>app::Builder</code> and <code>window::Builder</code> <code>max_capture_frame_jobs</code> and
<code>capture_frame_timeout</code> methods have been added to allow for specifying the
number of worker threads and optional timeout duration for the windows' inner
<code>TextureCapturer</code>s.</li>
</ul>
<hr />
<h3 id="nannou_laser-0143-2020-05-19"><a class="header" href="#nannou_laser-0143-2020-05-19"><code>nannou_laser</code> 0.14.3 (2020-05-19)</a></h3>
<ul>
<li>Add support for enabling/disabling draw path reordering.</li>
</ul>
<hr />
<h3 id="nannou_laser-0142-2020-05-15"><a class="header" href="#nannou_laser-0142-2020-05-15"><code>nannou_laser</code> 0.14.2 (2020-05-15)</a></h3>
<ul>
<li>Update <code>lasy</code> to 0.4. Adds better support for points and improved euler
circuit interpolation.</li>
</ul>
<hr />
<h3 id="nannou_laser-0141-2020-05-06"><a class="header" href="#nannou_laser-0141-2020-05-06"><code>nannou_laser</code> 0.14.1 (2020-05-06)</a></h3>
<ul>
<li>Add <code>ilda-idtf</code> feature to <code>nannou_laser</code>.</li>
</ul>
<hr />
<h3 id="nannou-0141-2020-05-06"><a class="header" href="#nannou-0141-2020-05-06"><code>nannou</code> 0.14.1 (2020-05-06)</a></h3>
<ul>
<li>Fix bug where <code>draw::Renderer</code> was initialised with an incorrect scale factor.</li>
<li>Fix <code>Vector::angle_between</code> implementation.</li>
</ul>
<hr />
<h1 id="version-0140-2020-04-24"><a class="header" href="#version-0140-2020-04-24">Version 0.14.0 (2020-04-24)</a></h1>
<ul>
<li>Relax trait bounds on many mesh types.</li>
<li>Add Rgb8 and Rgba8 type aliases.</li>
<li>Add <code>vec2.rotate(radians)</code>, <code>Vector2::from_angle</code>, <code>a.angle_between(b)</code>,
<code>vec.magnitude()</code> and <code>vec.magnitude2()</code> inherent methods.</li>
<li>Add <code>rgb_u32</code> for creating color from hex literals.</li>
<li>Fix <code>.z_radians()</code> behaviour.</li>
<li>Simplify the fullscreen API.
<a href="https://github.com/nannou-org/nannou/pull/521">#521</a>.</li>
<li>Adds a <code>set_version</code> script for synchronising version updates across nannou
crates.</li>
<li>Add a <code>random_ascii()</code> function.</li>
<li>Add many more "Generative Design" and "Nature of Code" examples.</li>
<li>Fix bug where <code>capture_frame_threaded</code> was not actually threaded.</li>
</ul>
<p><strong>The Great Repository Refactor</strong></p>
<ul>
<li>Move nannou src and tests into a <code>nannou</code> subdirectory.</li>
<li>Move <code>nannou_audio</code> into the nannou repo.</li>
<li>Move <code>nannou_isf</code> into the nannou repo.</li>
<li>Move <code>nannou_laser</code> into the nannou repo.</li>
<li>Move <code>nannou_osc</code> into the nannou repo.</li>
<li>Move <code>nannou_timeline</code> into the nannou repo.</li>
<li>Move guide into the nannou repo.</li>
<li>Add all crates under a single workspace.</li>
<li>Update README.md with a repository overview.</li>
<li>Move <code>run_all_examples.rs</code> test into a new <code>scripts/</code> directory. Add
ability to run examples of specific packages in the workspace.</li>
<li>Move <code>nature_of_code</code> examples</li>
<li>Move CHANGELOG into the guide.</li>
<li>Switch from travis CI to a github workflow.</li>
</ul>
<p><strong>Guide</strong></p>
<ul>
<li>Add a "Sketch vs App" tutorial.</li>
<li>Add a "Window Coordinates" tutorial.</li>
<li>Add "OSC Introduction" and "OSC Sender" tutorials.</li>
<li>Ensure the "Drawing 2D Shapes" tutorial code is tested.</li>
<li>Add automated testing of all guide code on each PR to nannou repo.</li>
</ul>
<p><strong>Draw API</strong></p>
<ul>
<li>Update to lyon 0.15.</li>
<li>Re-add support for colored vertices on polygons.</li>
<li>Added blend modes, e.g. <code>draw.blend(blend_desc)</code>.</li>
<li>Added scissor, e.g. <code>draw.scissor(rect)</code></li>
<li>Added transforms, e.g. <code>draw.scale(s)</code>, <code>draw.rotate(r)</code>.</li>
<li>Removed many relative positioning methods in favour of draw transforms.</li>
<li>Add <code>draw.texture</code> API.</li>
<li>Rename all APIs taking <code>points</code>, <code>points_colored</code> and <code>points_textured</code> to
take iterators yielding tuples, e.g. <code>point</code>, <code>(point, color)</code>, <code>(point, tex_coords)</code>.</li>
<li>Add support for <code>.points_textured(tex, pts)</code> to <code>draw.mesh()</code>,
<code>draw.path()</code> and <code>draw.polygon()</code>.</li>
<li>Add support for <code>draw.sampler(sampler_desc)</code>, for specifying a draw
context with a custom texture sampler.</li>
<li>Add <code>draw.triangle_mode()</code>, <code>draw.line_mode()</code> and <code>draw.point_mode()</code> for
switching between render pipeline primitive topology.</li>
<li>Add GPU caching of glyphs for text drawn via <code>draw.text()</code>. Allows for
much higher-performance text rendering.</li>
<li>Add <code>draw.arrow()</code> API.</li>
<li>New examples of the new APIs in the <code>nannou/examples/draw/</code> directory.</li>
</ul>
<p><strong>WGPU API</strong></p>
<ul>
<li>Simplified texture loading, e.g. <code>Texture::from_path</code> and
<code>Texture::from_image</code>.</li>
<li>Simplified <code>TextureView</code> creation via <code>Texture::view</code> builder.</li>
<li>Add <code>RenderPipelineBuilder</code>.</li>
<li>Add <code>BindGroupLayoutBuilder</code>.</li>
<li>Add <code>BindGroupBuilder</code>.</li>
<li>Add <code>RenderPassBuilder</code>.</li>
<li>Add <code>wgpu::shader_from_spirv_bytes</code> helper function.</li>
</ul>
<p><strong>LASER API</strong></p>
<ul>
<li>Add non-blocking LASER DAC detection via <code>Api::detect_dacs_async</code>.</li>
<li>Add error callback to LASER stream API.</li>
<li>Expose some missing setters on the LASER stream handles.</li>
<li>Add nicer socket address and error handling to <code>nannou_laser::ffi</code>.</li>
</ul>
<hr />
<h1 id="version-0131-2020-03-05"><a class="header" href="#version-0131-2020-03-05">Version 0.13.1 (2020-03-05)</a></h1>
<ul>
<li>Add <code>Texture::inner</code> producing a reference to the inner texture handle.</li>
<li>Add <code>Texture::into_inner</code> producing the inner texture handle.</li>
<li>Add <code>Into&lt;TextureHandle&gt;</code> impl for <code>Texture</code></li>
<li>Add <code>Texture::into_ui_image</code>.</li>
</ul>
<h1 id="version-0130-2020-03-05"><a class="header" href="#version-0130-2020-03-05">Version 0.13.0 (2020-03-05)</a></h1>
<ul>
<li>Transition from <code>vulkano</code> to <code>wgpu</code> for all graphics handling!
<ul>
<li>Fixes llooooooooooottss of macOS bugs.</li>
<li>The <code>draw</code> and <code>ui</code> APIs now render via wgpu.</li>
<li>Replace <code>vk</code> module with <code>wgpu</code> module.</li>
<li>Replace <code>examples/vulkan</code> with <code>examples/wgpu</code>.</li>
<li>Big step towards enabling web target.</li>
<li>Add <code>wgpu::TextureBuilder</code> to simplify texture building process.</li>
<li>Add <code>wgpu::TextureReshaper</code> for writing a texture to another of differing
size, format and sample_count.</li>
<li>Add <code>wgpu::TextureCapturer</code> for reading textures onto CPU as images.</li>
</ul>
</li>
<li>Update to <code>winit</code> 0.21. Another big step towards enabling web target. Also
includes an overhaul of the application loop which should be significantly
simpler.</li>
<li>Update <code>view</code> function API to take <code>Frame</code> by value rather than by reference.
For example, rather than:
<pre><code class="language-rust ignore">fn view(app: &amp;App, model: &amp;Model, frame: &amp;Frame) {}</code></pre>
the <code>view</code> function signature now must look like:
<pre><code class="language-rust ignore">fn view(app: &amp;App, model: &amp;Model, frame: Frame) {}</code></pre>
This was necessary to enable ergonomic texture capturing.</li>
<li><code>frame.submit()</code> can now be used to submit the frame to the GPU before the end
of the <code>view</code> function.</li>
<li><code>nannou::sketch</code> now returns a <code>SketchBuilder</code>. This allows for specifying the
sketch <code>.size(w, h)</code>, but now requires that <code>.run()</code> is called (or the sketch
won't do anything!).</li>
<li>A <code>.size(w, h)</code> builder has been added to the <code>app::Builder</code> type that allows
for specifying a default window size.</li>
<li>Add <code>window.capture_frame(path)</code> method for capturing the next frame to an
image file at the given file path.</li>
<li>Add a <code>simple_capture.rs</code> example.</li>
<li>Add a <code>capture_hi_res.rs</code> example.</li>
<li><code>sketch</code>'s now need a call to <code>.run()</code> to do anything.</li>
<li><code>sktech</code>'s now support a <code>.size(width, height)</code> builder method for setting
window size.</li>
<li>The <code>app::Builder</code> now also supports a <code>.size(width, height)</code> method for
specifying the default window width and height.</li>
<li><code>LoopMode</code>s have been simplified:
<ul>
<li><code>Wait</code> no longer requires <code>update_following_event</code> or <code>update_interval</code></li>
<li><code>NTimes</code> no longer requires <code>update_interval</code></li>
<li><code>Refresh</code> no longer requires <code>minimum_update_interval</code> or <code>windows</code></li>
</ul>
</li>
</ul>
<hr />
<h1 id="version-0120-2019-11-03"><a class="header" href="#version-0120-2019-11-03">Version 0.12.0 (2019-11-03)</a></h1>
<ul>
<li>Update vulkano dependencies to 0.16 in order to address <code>metal</code> related bug on
macOS.</li>
<li>Update conrod dependencies to 0.68 for vulkano patch. New version includes
copy/paste, double-click select and shift-click select support for the
<code>TextEdit</code> widget.</li>
<li>[Breaking] Small change to Vulkan debug items.</li>
<li>[Breaking] New fields have been added to <code>DynamicState</code>.</li>
<li>Update shade_runner to 0.3 for vulkano patch.</li>
<li>Frame command buffer builder no longer provides access to unrelated
<code>secondary</code> buffer methods.</li>
</ul>
<hr />
<h1 id="version-0110-2019-09-17"><a class="header" href="#version-0110-2019-09-17">Version 0.11.0 (2019-09-17)</a></h1>
<ul>
<li>Update vulkano and shaderc dependencies to fix linux build issues.</li>
<li>Add an example that demonstrates using the Draw API with multiple windows.</li>
<li>Fix a bug where <code>Draw::to_frame</code> would <code>panic!</code> when used between multiple
windows.</li>
<li>Add lyon for 2D tessellation.</li>
<li>A new <code>geom::path()</code> API has been added that allows for building 2D vector
graphics paths as an iterator yielding <code>lyon::path::PathEvent</code>s. This adds
support for curves, arcs, sub-paths and more.</li>
<li>A <code>draw.path()</code> API has been added to allow for taking advantage of paths via
the <code>Draw</code> API. <code>draw.path().stroke()</code> produces a path that will be rendered
via stroke tessellation, <code>draw.path().fill()</code> produces a path that will be
rendered via fill tessellation.</li>
<li>The <code>draw.polyline()</code> and <code>draw.line()</code> APIs are now implemented in terms of
<code>draw.path().stoke()</code>.</li>
<li>All known polyline bugs should be fixed.</li>
<li><code>draw.polygon()</code> has been updated to use lyon's <code>FillTessellator</code> allowing for
concave shapes.</li>
<li><code>draw.polygon()</code> now supports optional stroke tessellation of its outline and
includes a suite of stroke option builder methods including line join types,
stroke weight, stroke color, etc. See the <code>SetStroke</code> method docs to find all
new methods now available.</li>
<li><code>.no_fill()</code> and <code>.stroke(color)</code> can be called on all polygon types to
indicate that no fill tessellation is required or to specify stroke color
respectively.</li>
<li>All other <code>draw</code> API polygons (<code>rect</code>, <code>quad</code>, <code>tri</code>, <code>ellipse</code>) have been
implemented in terms of <code>draw.polygon()</code>, allowing them to take advantage of
the same stroke tessellation options.</li>
<li>The line <code>thickness</code> methods have been replaced with <code>stroke_weight</code> and
<code>weight</code> methods.</li>
<li>Fixes a pretty severe bug where any draw primitives that use the intermediary
mesh would produce incorrect triangulation indices if they weren't the first
instance to be created.</li>
<li><code>draw.polygon()</code> will temporarily lose support for individually colored
vertices. This is due to limitations with lyon's <code>FillTessellator</code>, however
these are in the process of being addressed.</li>
<li><code>draw.tri()</code> and <code>draw.quad()</code> now expect <code>Point2</code>s instead of <code>Point3</code>s. This
was a trade-off in order to take advantage of the lyon tessellators which only
support 2D geometry. Currently, the draw API's 3D story is very limited
anyway, and this can likely be revisited as a part of a larger 3D tessellation
overhaul. For now, <code>draw.mesh()</code> can still be used for drawing arbitrary 3D
via the <code>draw</code> API.</li>
<li>Introduce notosans crate for guaranteed default fallback font. Can be disabled
by disabling default-features.</li>
<li>Refactor default font out of ui module into app module.</li>
<li>Add <code>text</code> module along with <code>text::Builder</code> and <code>Text</code> APIs. Allows for
laying out multi-line, justified, auto-wrapping text.</li>
<li>Add <code>draw.text("foo")</code> API. Currently quite slow as it uses the <code>draw.path()</code>
API internally, but this can be improved in the future by adopting a glyph
cache.</li>
<li>Add <code>simple_text.rs</code> and <code>simple_text_path.rs</code> examples.</li>
</ul>
<hr />
<h1 id="version-0100-2019-07-21"><a class="header" href="#version-0100-2019-07-21">Version 0.10.0 (2019-07-21)</a></h1>
<ul>
<li>Change the <code>view</code> function signature to take <code>Frame</code> by reference rather than
by value.</li>
<li>Remove depth format constants in favour of querying supported formats.</li>
<li>Update from palette 0.2 to 0.4.</li>
<li>Add shorthand color constructors to the <code>color</code> module.</li>
<li>Remove nannou named colors in favour of using palette's.</li>
<li>Added a <code>named_color_reference.rs</code> example for finding suitable colors and to
act as a test of color accuracy.</li>
<li>Change the <code>Frame</code> image type from the swapchain color format (non-linear
sRGB) to a linear sRGB format for better consistency across platforms.</li>
<li>Add Window::rect method.</li>
<li>Add <code>simple_audio_file.rs</code> playback example.</li>
<li>Add a new <code>NTimes</code> loop mode.</li>
<li>Separate the OSC API out into a <code>nannou_osc</code> crate.</li>
<li>Separate the audio API out into a <code>nannou_audio</code> crate.</li>
<li>Update laser examples for switch from <code>lasy</code> to <code>nannou_laser</code>.</li>
<li>Update deps:
<ul>
<li>rand 0.7</li>
<li>conrod 0.66</li>
<li>vulkano 0.13</li>
</ul>
</li>
</ul>
<hr />
<h1 id="version-090-2019-05-28"><a class="header" href="#version-090-2019-05-28">Version 0.9.0 (2019-05-28)</a></h1>
<ul>
<li>Change graphics rendering backend from glium to vulkano! This affects a wide
range of nannou's API including:
<ul>
<li>Window creation and methods. Each window now has it's own associated Vulkan
swapchain and related methods.</li>
<li>The <code>Frame</code> API now wraps a single swapchain image and a vulkan command
buffer builder.</li>
<li>The <code>draw</code> API's renderer now renders via a vulkan pipeline.</li>
<li>The <code>Ui</code> API's renderer now renders via a vulkan pipeline.</li>
<li>The <code>App</code> includes methods for accessing the vulkan instance.</li>
<li>The <code>App</code> can be built with a custom vulkan instance and custom debug
callback function.</li>
<li>A suite of examples demonstrating low-level vulkano access have been added.</li>
</ul>
</li>
<li>Improve the clarity of the <code>App</code> creation process by introducing an
<code>app::Builder</code> type. Examples have been updated accordingly.</li>
<li>The <code>view</code> function is now called separately for each frame for each window,
rather than a single frame for all windows at once. The window a frame is
associated with can be determined via <code>Frame::window_id</code>.</li>
<li>A suite of new event handling functions have been added as an alternative to
matching on the raw <code>Event</code> type. This has simplified a lot of the examples.
See the <code>app::Builder</code> and <code>window::Builder</code> docs for the newly available
methods and more documentation.</li>
<li>Add <code>Window::grab_cursor</code> and <code>Window::hide_cursor</code> methods.</li>
<li>Add <code>window::SwapchainFramebuffers</code> helper type.</li>
<li>Add <code>vk::Framebuffer</code> to simplify framebuffer management.</li>
<li>Remove the <code>state::time::Duration</code> type in favour of a <code>DurationF64</code> trait.</li>
<li>Prefer sRGB colour formats when building swapchain.</li>
<li>Update deps:
<ul>
<li>conrod crates 0.65</li>
<li>image 0.21</li>
<li>noise 0.5</li>
<li>pennereq 0.3</li>
<li>rand 0.6</li>
<li>sample 0.10</li>
<li>winit 0.19</li>
</ul>
</li>
<li>Fix mouse positioning on HiDPI macOS displays.</li>
<li>Draw to an intermediary frame before resolving to the swapchain to simplify
MSAA and keeping the image consistent between frames.</li>
<li>Add some laser streaming examples using the <code>nannou-org/lasy</code> crate.</li>
</ul>
<hr />
<h1 id="version-080-2018-07-19"><a class="header" href="#version-080-2018-07-19">Version 0.8.0 (2018-07-19)</a></h1>
<ul>
<li>Update deps: glium 0.22, image 0.19.</li>
<li>Change <code>random_range</code> to check that <code>min</code> is smaller than <code>max</code>, swapping the
two if not. This avoids some common <code>panic!</code>s.</li>
<li>Add expanding conversion implementations that vector types.</li>
<li>Add custom <code>Vector</code> types - replaces the use of <code>cgmath::{VectorN, PointN}</code>
types.</li>
<li>Update <code>rand</code> to version <code>0.5</code>.</li>
<li>Add <code>geom::scalar</code> module. Move <code>DefaultScalar</code> to <code>scalar::Default</code>.</li>
<li>Fix the order of <code>geom::line</code> vertices.</li>
<li>Add a <code>draw.polygon()</code> API.</li>
<li>Remove <code>geom::polyline</code> module.</li>
<li>Add <code>geom::line::join</code> module with <code>miter</code> submodule implementation.</li>
</ul>
<hr />
<h1 id="version-070-2018-06-13"><a class="header" href="#version-070-2018-06-13">Version 0.7.0 (2018-06-13)</a></h1>
<ul>
<li>Add better <code>panic!</code> message to <code>map_range</code> if cast fails.</li>
<li>Add many items to prelude (audio, io, math, osc, ui, window).</li>
<li>Change event positioning types to use DefaultScalar.</li>
<li>Implement <code>draw.polygon()</code></li>
<li>Implement <code>draw.mesh()</code></li>
<li>Update internal <code>IntoDrawn</code> API to support a dynamic number of arbitrary
vertices.</li>
<li>Update <code>Drawing</code> API to allow builders to produce new <code>Drawing</code> types.</li>
</ul>
<hr />
<h1 id="version-060-2018-06-07"><a class="header" href="#version-060-2018-06-07">Version 0.6.0 (2018-06-07)</a></h1>
<ul>
<li>Add beginnings of Nature of Code and Generative Gestaltung examples.</li>
<li>Add <code>App::elapsed_frames</code> method.</li>
<li>Remove <code>app.window.id</code> field in favour of more reliable <code>app.window_id</code>
method.</li>
<li>Change <code>ui::Builder</code> so that it no longer requires <code>window::Id</code>. Now defaults
to focused window.</li>
<li>Fix several HiDPI related bugs introduced in the last winit update.</li>
<li>Add support for rotation and orientation to <code>draw</code> API.</li>
</ul>
<hr />
<h1 id="version-052-2018-04-28"><a class="header" href="#version-052-2018-04-28">Version 0.5.2 (2018-04-28)</a></h1>
<ul>
<li>Improve efficiency of the <code>App</code> proxy by only making OS calls when needed.</li>
</ul>
<h1 id="version-051-2018-04-26"><a class="header" href="#version-051-2018-04-26">Version 0.5.1 (2018-04-26)</a></h1>
<ul>
<li>Add <code>Ui::draw_to_frame_if_changed</code> method which only draws if necessary.</li>
<li>Add README to nannou-package.</li>
<li>Add missing <code>Cargo.toml</code> details to nannou-package.</li>
<li>Add an <code>io</code> module with some helper functions simplifying <code>std::io</code>.</li>
<li>Add <code>fmod</code> function to <code>math</code> module.</li>
</ul>
<h1 id="version-050-2018-04-17"><a class="header" href="#version-050-2018-04-17">Version 0.5.0 (2018-04-17)</a></h1>
<ul>
<li>Add simple accessor field for getting the time since app start in secs.</li>
<li>Add ability to adjust glyph cache size for text (ui).</li>
<li>Update to glium 0.21 and conrod 0.59.</li>
<li>Remove <code>app.window.*</code> fields in favour of <code>app.window_rect()</code> method.</li>
<li>Enable vsync and 4x multisampling by default.</li>
<li>Add fullscreen toggle keyboard shortcuts.</li>
<li>Add <code>nannou-new</code> and <code>nannou-package</code> tools.</li>
<li>Add <code>Draw::line</code> along with custom line builders to <code>Drawing</code>.</li>
<li>Change <code>draw::Background</code> coloring API to match the <code>SetColor</code> API.</li>
<li>Change OSC default binding address from <code>127.0.0.1</code> to <code>0.0.0.0</code>.</li>
<li>Add many new items to prelude.</li>
<li>Add more <code>Rect</code> constructors.</li>
<li>Add <code>Range::lerp</code> method.</li>
<li>Window name defaults to "nannou - exe_name" if no name is given.</li>
<li>Correct existing and add missing geometry scalar default types.</li>
</ul>
<hr />
<h1 id="version-040-2018-03-25"><a class="header" href="#version-040-2018-03-25">Version 0.4.0 (2018-03-25)</a></h1>
<ul>
<li>Add hsv (aka hsb) color builder methods to Draw API.</li>
<li>Add nicer panic message for when <code>max_supported_input/output_channels</code> methods
fail.</li>
<li>Add <code>Ellipse::triangle_indices</code> method.</li>
<li>Improve efficiency of <code>geom::graph::node::Transform</code>.</li>
<li>Add a <code>Duration</code> wrapper with simpler access methods (<code>secs</code>, <code>ms</code>, etc).</li>
<li>Add <code>quad</code>, <code>rect</code> and <code>tri</code> methods to <code>Draw</code> API.</li>
<li>Add <code>draw::mesh::vertex::IntoPoint</code> trait with many impls.</li>
<li>Add <code>geom::centroid</code> function.</li>
<li>Add <code>Quad::bounding_rect</code> and <code>bounding_cuboid</code> methods.</li>
<li>Add more <code>geom::Vertex</code> impls.</li>
<li>Add <code>Drawing&lt;Ellipse&gt;::radius</code> method.</li>
<li>Fix bug in audio input stream.</li>
<li>Add simpler <code>Frame</code> clear methods.</li>
<li>Add simpler <code>App</code> constructors.</li>
<li>Fix bug where mesh types would not clear properly.</li>
<li>Remove <code>color</code> module from prelude to avoid <code>ui</code> module conflicts.</li>
<li>Add named colors.</li>
<li>Add <code>draw</code> module. A high-level, simple, expressive graphics API.</li>
<li>Add <code>mesh</code> module. Supports meshes with custom channels and layouts.</li>
<li>Add <code>geom::Graph</code> for composing together geometric primitives.</li>
<li>Add new triangles iterators to <code>geom::quad</code> and <code>geom::rect</code> modules.</li>
<li>Add <code>geom::cuboid</code> module.</li>
<li>Add <code>geom::polyline</code> module.</li>
<li>Add <code>geom::line</code> module.</li>
</ul>
<hr />
<h1 id="version-030-2018-02-18"><a class="header" href="#version-030-2018-02-18">Version 0.3.0 (2018-02-18)</a></h1>
<ul>
<li>Add <code>audio::Stream::id</code> method.</li>
<li>Add <code>ExactSize</code> and <code>DoubleEnded</code> iterator implementations for
<code>audio::Buffer</code>.</li>
<li>Update for input stream support.</li>
<li>Add support for audio input devices and streams</li>
<li>Expose helper Vector and Point constructors in prelude.</li>
<li>Add <code>state</code> module for tracking mouse, keyboard and window state.</li>
<li>Add <code>geom</code> module. Includes basic 2D primitives (lines/text).</li>
<li>Add <code>ease</code> module which re-exports the <code>pennereq</code> crate.</li>
<li>Add <code>map_range</code>, <code>partial_max</code>, <code>min</code>, <code>clamp</code> math functions</li>
<li>Begin implementation of  tutorial <code>basics</code> examples.</li>
</ul>
<hr />
<h1 id="version-020-2017-12-12"><a class="header" href="#version-020-2017-12-12">Version 0.2.0 (2017-12-12)</a></h1>
<ul>
<li>Add support for audio output device and streams.</li>
<li>Add OSC support.</li>
</ul>
<hr />
<br>
<center>BEGINNING OF CHANGELOG</center>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>This project exists thanks to all the people who contribute.</p>
<p><a href="https://github.com/nannou-org/nannou/graphs/contributors"><img src="https://opencollective.com/nannou/contributors.svg?width=890&button=false" /></a></p>
<h2 id="backers"><a class="header" href="#backers">Backers</a></h2>
<p>Thank you to all our backers! 🙏</p>
<p><a href="https://opencollective.com/nannou#backers" target="_blank"><img src="https://opencollective.com/nannou/backers.svg?width=890"></a></p>
<h2 id="sponsors"><a class="header" href="#sponsors">Sponsors</a></h2>
<p>Support this project by becoming a sponsor. Your logo will show up here with a link to your website.</p>
<p><a href="https://opencollective.com/nannou/sponsor/0/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/0/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/1/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/1/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/2/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/2/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/3/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/3/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/4/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/4/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/5/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/5/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/6/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/6/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/7/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/7/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/8/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/8/avatar.svg"></a>
<a href="https://opencollective.com/nannou/sponsor/9/website" target="_blank"><img src="https://opencollective.com/nannou/sponsor/9/avatar.svg"></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributor-covenant-code-of-conduct"><a class="header" href="#contributor-covenant-code-of-conduct">Contributor Covenant Code of Conduct</a></h1>
<h2 id="our-pledge"><a class="header" href="#our-pledge">Our Pledge</a></h2>
<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>
<h2 id="conduct"><a class="header" href="#conduct">Conduct</a></h2>
<ul>
<li>We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.</li>
<li>Please be kind and courteous. There’s no need to be mean or rude.</li>
<li>Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.</li>
<li>Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.</li>
<li>We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We interpret the term “harassment” as including the definition in the Citizen Code of Conduct; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don’t tolerate behavior that excludes people in socially marginalized groups.</li>
<li>Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the Nannou moderation team immediately. Whether you’re a regular contributor or a newcomer, we care about making this community a safe place for you and we’ve got your back.</li>
<li>Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome.</li>
</ul>
<h2 id="moderation"><a class="header" href="#moderation">Moderation</a></h2>
<p>These are the policies for upholding our community’s standards of conduct. If you feel that a thread needs moderation, please contact the <a href="mailto:contact@nannou.cc">Nannou moderation team</a>:</p>
<ol>
<li>Remarks that violate the Nannou standards of conduct, including hateful, hurtful, oppressive, or exclusionary remarks, are not allowed. (Cursing is allowed, but never targeting another user, and never in a hateful manner.)</li>
<li>Remarks that moderators find inappropriate, whether listed in the code of conduct or not, are also not allowed.</li>
<li>Moderators will first respond to such remarks with a warning.</li>
<li>If the warning is unheeded, the user will be “kicked,” i.e., kicked out of the communication channel to cool off.</li>
<li>If the user comes back and continues to make trouble, they will be banned, i.e., indefinitely excluded.</li>
<li>Moderators may choose at their discretion to un-ban the user if it was a first offense and they offer the offended party a genuine apology.</li>
<li>If a moderator bans someone and you think it was unjustified, please take it up with that moderator, or with a different moderator, in private. Complaints about bans in-channel are not allowed.</li>
<li>Moderators are held to a higher standard than other community members. If a moderator creates an inappropriate situation, they should expect less leeway than others.</li>
</ol>
<p>In the Nannou community we strive to go the extra step to look out for each other. Don’t just aim to be technically unimpeachable, try to be your best self. In particular, avoid flirting with offensive or sensitive issues, particularly if they’re off-topic; this all too often leads to unnecessary fights, hurt feelings, and damaged trust; worse, it can drive people away from the community entirely.</p>
<p>And if someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize. Even if you feel you were misinterpreted or unfairly accused, chances are good there was something you could’ve communicated better — remember that it’s your responsibility to make your fellow members of the community comfortable. Everyone wants to get along and we are all here first and foremost because we want to talk about cool technology. You will find that people will be eager to assume good intent and forgive as long as you earn their trust.</p>
<h2 id="our-responsibilities"><a class="header" href="#our-responsibilities">Our Responsibilities</a></h2>
<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p>
<p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>
<h2 id="enforcement"><a class="header" href="#enforcement">Enforcement</a></h2>
<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at <a href="mailto:contact@nannou.cc"><strong>contact@nannou.cc</strong></a>. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p>
<p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>This Code of Conduct is adapted from the <a href="http://contributor-covenant.org">Contributor Covenant</a>, version 1.4, available at <a href="http://contributor-covenant.org/version/1/4/">http://contributor-covenant.org/version/1/4</a> as well as the <a href="http://blog.izs.me/post/30036893703/policy-on-trolling">Node.js Policy on Trolling</a> and the <a href="https://www.rust-lang.org/en-US/conduct.html">Rust Code of Conduct</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
